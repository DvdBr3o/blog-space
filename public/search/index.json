[{"content":"微分形式\raka 外微分形式\n重要微分形式\r在 $\\mathbb{R}^{n}$ 域下\n零阶微分形式：光滑函数\n一阶微分形式 $$ \\sum_{i=1}^{n} f_{i}(\\dots),\\mathrm{d}x_{i} $$\n二阶微分形式 $$ \\sum_{i,j=1}^{n} f_{ij}(\\dots),\\mathrm{d}x_{i} \\land ,\\mathrm{d}x_{j} $$\n记号\r记 $\\Lambda_{m}(D)$ 是在 $D\\in \\mathbb{R}^{n}$ 的所有 $m$ 阶微分形式的集合\n运算\r线性运算\r把微分形式看成多项式，每一项看作一阶线性空间的一维\n数乘 加减 外积运算\r对于 $m$ 阶的外微分形式 $\\mathrm{d}x_{1}\\land \\mathrm{d}x_{2}\\land\\dots \\land \\mathrm{d}x_{m}$ 中的任意连续两项$$\\mathrm{d}x_{i}\\land \\mathrm{d}x_{j}=-,\\mathrm{d}x_{j}\\land \\mathrm{d}x_{i}$$ $\\mathrm{d}x_{i}\\land \\mathrm{d}x_{i}=0$ 外微分运算\r0 $\\to$ 1 (全微分运算) $$\\mathrm{d}F(x_{1},\\dots,x_{n})=\\sum_{i=1}^{n} \\frac{ \\partial F }{ \\partial x_{1} } \\mathrm{d}x_{i}$$ 1 $\\to$ 2 $$\\mathrm{d}\\left( \\sum_{i=1}^{n} f_{i},\\mathrm{d}x_{i} \\right)=\\sum_{i=1}^{n} \\mathrm{d}f_{i}\\land \\mathrm{d}x_{i}$$ 庞加莱定理\r恰当微分\r已知 $\\omega \\in \\Lambda_{m}(D)$ $\\exists ,\\Omega$ s.t. $\\mathrm{d}\\Omega=\\omega$ 结论 $\\omega$ 是 恰当微分 闭的微分形式\r已知 $\\omega \\in\\Lambda_{m}(D)$ $\\mathrm{d}\\omega=0$ 结论 $\\omega$ 是 闭的微分形式 庞加莱定理\r恰当微分是闭的 aka $$ \\mathrm{d}\\mathrm{d}\\Omega=0 $$\n应用\r一般形式の环积分公式\r公式 一般形式 条件 格林公式 $$\\int_{S}\\omega=\\iint_{\\Omega}\\mathrm{d}\\omega$$ 高斯公式 $$\\iint_{S}\\omega=\\iiint_{\\Omega}\\mathrm{d}\\omega$$\n斯托克斯公式 $$\\int_{S}\\omega=\\iint_{\\Omega}\\mathrm{d}\\omega$$ 统一表述 $$\\int_{\\partial \\sum}\\omega=\\int_{\\sum}\\mathrm{d}\\omega$$ $\\omega$ 在 $\\sum \\cap ,\\partial \\sum$ 上光滑 其中 $\\partial \\sum$ 是 $\\sum$ 的边界 统一表述与牛顿莱布尼茨公式\r牛顿莱布尼茨公式 $$\\int_{a}^{b} f(x) , dx = F(b) - F(a)$$ 可以把 $(a,b)$ 看作 $\\sum$，则其边界为 $\\partial \\sum=\\left{ a,b \\right}$ 所以遵守统一表述 $\\int_{\\partial \\sum}\\omega=\\int_{\\sum}\\mathrm{d}\\omega$\n外微分意义下的场论\r在 $\\mathbb{R}^{3}$ 下\n度 外微分阶数 意义 梯度 $\\mathrm{grad}$ 0 $\\to$ 1 零阶微分形式 的 外微分运算 旋度 $\\mathrm{rot}$ 1 $\\to$ 2 一阶微分形式 的 外微分运算 散度 $\\mathrm{div}$ 2 $\\to$ 3 二阶微分形式 的 外微分运算 场论中的庞加莱定理\r$$ \\mathrm{d}\\mathrm{d}\\Omega=0 $$ $\\implies$ $$ \\mathrm{grad},\\mathrm{rot},f=0 $$ $$ \\mathrm{rot},\\mathrm{div},f=0 $$\n","date":"2025-02-08T21:27:03+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86/%E5%A4%96%E5%BE%AE%E5%88%86/","title":"外微分"},{"content":"应用\r空间 曲线 环积分 已知\r曲面 $S$ 正向约定 法向量 $\\vec{n}$ 与曲线 $L$ 方向成右手系 $S+L$ 有一阶连续偏导 结论\r朴素形式\r$$ \\oint_{L+}P,dx+Q,dy+R,dz=\\iint_{S+}\\left( \\frac{\\partial R}{\\partial y}-\\frac{\\partial Q}{\\partial z} \\right),dx+\\left( \\frac{\\partial P}{\\partial z}-\\frac{\\partial R}{\\partial x} \\right),dy+\\left( \\frac{\\partial Q}{\\partial x}-\\frac{\\partial P}{\\partial y} \\right)\n$$\n朴素行列式形式\r$$ \\oint_{L+}P,dx+Q,dy+R,dz=\\iint_{S+}\\left| \\begin{matrix} dy,dz\u0026amp; dx,dz\u0026amp; dx,dy \\ \\frac{\\partial}{\\partial x}\u0026amp; \\frac{\\partial}{\\partial y}\u0026amp; \\frac{\\partial}{\\partial z} \\ P\u0026amp; Q\u0026amp; R \\end{matrix} \\right| $$\n旋度形式\r由\r朴素行列式形式\r可以引出旋度 $\\mathrm{rot}$\n$$ \\oint_{L+}\\vec{F},d\\vec{S} = \\iint_{S+}\\mathrm{rot},\\vec{F}\\cdot d\\vec{S} $$\n其中\n$$ \\begin{align} \\mathrm{rot},\\vec{F} \u0026amp; =\\mathrm{rot},\\left( P,Q,R \\right) \\ \u0026amp; = \\left| \\begin{matrix} \\vec{i}\u0026amp; \\vec{j}\u0026amp; \\vec{k} \\ \\frac{\\partial}{\\partial x}\u0026amp; \\frac{\\partial}{\\partial y}\u0026amp; \\frac{\\partial}{\\partial z} \\ P\u0026amp; Q\u0026amp; R \\end{matrix} \\right| \\end{align} $$ $$ \\begin{align} d\\vec{S} \u0026amp; =(\\cos\\alpha,\\cos\\beta,\\cos\\gamma)\\cdot dS \\ \u0026amp; =(dy,dz,dx,dz,dx,dy) \\end{align} $$\n旋度变式形式\r$$ \\oint_{L+}\\vec{F},d\\vec{S}=\\left| \\begin{matrix} \\cos\\alpha \u0026amp; \\cos\\beta \u0026amp; \\cos\\gamma \\ \\frac{\\partial}{\\partial x}\u0026amp; \\frac{\\partial}{\\partial y}\u0026amp; \\frac{\\partial}{\\partial z} \\ P\u0026amp; Q\u0026amp; R \\end{matrix} \\right| ,dS $$\n证明\r略\n","date":"2025-02-08T14:07:02+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86/%E6%96%AF%E6%89%98%E5%85%8B%E6%96%AF%E5%85%AC%E5%BC%8F/","title":"斯托克斯公式"},{"content":"场\r数量场 $f:(x,y,z)\\to \\mathrm{val}$ 向量场 $f:(x,y,z)\\to(\\alpha,\\beta,\\gamma)$ 关键量对比\r量 度 类型映射 实现 方向向量/等值面 梯度 $\\mathrm{grad}$ 数量场 $\\to$ 向量场 $\\mathrm{grad},f=\\left( \\frac{ \\partial f }{ \\partial x },\\frac{ \\partial f }{ \\partial y },\\frac{ \\partial f }{ \\partial z } \\right)$ 通量 散度 $\\mathrm{div}$ 向量场 $\\to$ 值 (通量) $\\mathrm{div},\\vec{F}=\\frac{ \\partial P }{ \\partial x }+\\frac{ \\partial Q }{ \\partial y }+\\frac{ \\partial R }{ \\partial z }$ 旋量 旋度 $\\mathrm{rot}$ 向量场 $\\to$ 向量场 $\\mathrm{rot},\\vec{F}=\\left| \\begin{matrix}\\vec{i} \u0026amp; \\vec{j} \u0026amp; \\vec{k} \\ \\frac{ \\partial }{ \\partial x } \u0026amp; \\frac{ \\partial }{ \\partial y } \u0026amp; \\frac{ \\partial }{ \\partial z } \\ P \u0026amp; Q \u0026amp; R\\end{matrix} \\right|$ ($\\mathrm{rot}$ 实现显示有误，不是双竖线)\n微分场论\r等值面\r$$ M_{C} = \\left{ (x,y,z),|,f(x,y,z)=C \\right} $$\n梯度\r已知数量场 $$u=f(x,y,z)$$ 则其梯度为一向量场如下 $$ \\nabla f=\\mathrm{grad},f=\\left( \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y}, \\frac{\\partial f}{\\partial z} \\right) $$\n几何意义\r梯度是当前点等值面の法向量 梯度指向当前点最大方向导数の方向 运算法则\r符合 类导数 四则运算法则 $\\nabla C=0$ $\\nabla(u\\pm v)=\\nabla u\\pm \\nabla v$ $\\nabla(u\\cdot v)=u\\nabla v+v\\nabla u$ $\\nabla \\frac{u}{v}=\\frac{1}{v^{2}}\\left( v\\nabla u-u\\nabla v \\right)$ 符合 类导数 链式法则 $\\nabla\\phi(u)=\\phi\u0026rsquo;(u)\\nabla u$ $\\nabla \\phi(u,v)=\\phi\u0026rsquo;{u}\\nabla u+\\phi\u0026rsquo;{v}\\nabla v$ $\\dots$ 积分场论\r通量\r向量场 $\\vec{F}$ 在曲面 $S$ 上的第二型曲面积分 $$ \\iint_{S} \\vec{F}\\cdot \\vec{n},dS $$ aka $$ \\iint_{S}\\vec{F},d\\vec{S} $$\n物理意义\r通量 $=$ 流出量 $-$ 流入量 散度\r已知\n空间 $V$ $m(V)$ 表示 $V$ 的体积 任一点 $M_{0} \\in V$ 向量场 $$\\vec{u}=\\vec{F}(x,y,z)$$ 则其散度为 $$ \\nabla\\cdot \\vec{F}= \\mathrm{div},\\vec{F}=\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z} $$ 定义概念\r由积分中值定理，散度在特定点の定义式为 $$ \\mathrm{div},\\vec{F}|{M{0}}=\\lim_{ V \\to M_{0} } \\frac{\\iiint \\vec{F},d\\vec{S}}{m(V)} $$ 可以理解为，散度可以看作点附近单位体积内的的通量。\n由此引入 点\u0026amp;散度 の相关概念\n源：点の散度 $\u0026gt;0$ 漏：点の散度 $\u0026lt;0$ 非源非漏：点の散度 $=0$ 无源场/管形场：场内 $\\mathrm{div},\\vec{F}(M)\\equiv 0$ 运算法则\r符合 数乘\u0026amp;加减 の 线性运算 $\\mathrm{div},(\\lambda\\vec{F})=\\lambda,\\mathrm{div},\\vec{F}$ $\\mathrm{div}\\left( \\vec{F_{1}} \\pm \\vec{F_{2}} \\right)=\\mathrm{div},\\vec{F_{1}}+\\mathrm{div},\\vec{F_{2}}$ $\\mathrm{div}\\left( \\phi,\\vec{F} \\right)=\\phi ,\\mathrm{div}, \\vec{F}+\\vec{F}\\cdot \\mathrm{grad},\\phi$，其中 $\\phi$ 是数量场 $$\\mathrm{div},\\mathrm{grad},\\phi=\\frac{\\partial^{2} \\phi}{\\partial x^{2}}+\\frac{\\partial^{2} \\phi}{\\partial y^{2}}+\\frac{\\partial^{2} \\phi}{\\partial z^{2}}$$ aka $\\nabla\\cdot,\\nabla, \\phi=\\Delta$ 其中 $\\Delta$ 是拉普拉斯算子，$$\\Delta=\\frac{\\partial^{2}}{\\partial x^{2}}+\\frac{\\partial^{2}}{\\partial y^{2}}+\\frac{\\partial^{2}}{\\partial z^{2}}$$ 环量\r已知向量场 $\\vec{F}=P,\\vec{i}+Q,\\vec{j}+R,\\vec{k}$ 则其环量为$$ \\begin{align} I \u0026amp; =\\oint_{L}P,\\mathrm{d}x+Q,\\mathrm{d}y+R,\\mathrm{d}z \\ \u0026amp; =\\oint_{L}\\vec{F}\\cdot ,\\mathrm{d}\\vec{r} \\ \u0026amp; =\\oint_{L}\\vec{F}\\cdot \\left( \\mathrm{d}x,,\\mathrm{d}y,,\\mathrm{d}z \\right) \\end{align} $$\n环量面密度\raka 方向旋量\n$$ \\frac{\\lim_{ \\lambda(S) \\to 0 } \\oint_{L}\\vec{F},\\mathrm{d}\\vec{r}}{m(S)} $$ 其中\n$\\lambda(S)$ 为 $S$ 的直径 $m(S)$ 为 $S$ 的面积 旋度\r$$ \\mathrm{rot},\\vec{F}=\\left| \\begin{matrix} \\vec{i} \u0026amp; \\vec{j} \u0026amp; \\vec{k} \\ \\frac{ \\partial }{ \\partial x } \u0026amp; \\frac{ \\partial }{ \\partial y } \u0026amp; \\frac{ \\partial }{ \\partial z } \\ P \u0026amp; Q \u0026amp; R \\end{matrix} \\right| $$\n运算法则\r已知 $F$, $G$ 为向量场，$u$ 为数量场，足够阶可微，$C$ 为常数\n符合 数乘\u0026amp;加减 の 线性运算 $\\mathrm{rot}\\left( C\\vec{F} \\right)=C\\cdot \\mathrm{rot},\\vec{F}$ $\\mathrm{rot}\\left( \\vec{F}\\pm \\vec{G} \\right)=\\mathrm{rot},\\vec{F}\\pm \\mathrm{rot},\\vec{G}$ 数向内旋$$\\mathrm{rot}\\left( u\\vec{F} \\right)=u,\\mathrm{rot},\\vec{F}+\\mathrm{grad},u \\times \\vec{F} $$ 向向外散$$\\mathrm{div}\\left( \\vec{F}\\times \\vec{G} \\right) = \\vec{G}\\cdot \\mathrm{rot},\\vec{F}-\\vec{F}\\cdot \\mathrm{rot},\\vec{G}$$ 数量场归零$$\\mathrm{rot}\\left( \\mathrm{grad},u \\right)=0 $$ 向量场归零$$\\mathrm{div}\\left( \\mathrm{rot},\\vec{F} \\right)=0 $$ 保守场\r以下三个命题等价\n$\\vec{F}$ 在 $D$ 内是保守场 $\\vec{F}$ 在 $D$ 内任意闭曲线环量为零，aka. $$\\oint_{\\Gamma}\\vec{F}\\cdot ,\\mathrm{d}\\vec{r}=0$$ $\\vec{F}$ 在 $D$ 内是无旋场，aka. $$\\mathrm{rot},\\vec{F}=0$$ ","date":"2025-02-08T13:58:53+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86/%E5%9C%BA%E8%AE%BA%E5%88%9D%E6%AD%A5/","title":"场论初步"},{"content":"总结\r环积分转化公式主要有三：\n格林公式 高斯公式 斯托克斯公式 公式 自由度 转化积分 lhs 转化积分 rhs 格林公式 平面 一元环 二元 斯托克斯公式 空间 一元环 二元 高斯公式 空间 二元环 三元 公式链接\r格林公式\r高斯公式\r斯托克斯公式\r","date":"2025-02-07T20:24:43+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86/%E7%8E%AF%E7%A7%AF%E5%88%86%E8%BD%AC%E5%8C%96%E5%85%AC%E5%BC%8F/","title":"环积分转化公式"},{"content":"已知\r曲面 $S$ 封闭 无奇点 结论\r朴素形式\r$$ {\\subset!\\supset} \\mathllap{\\iint}{S} P,dy,dz+Q,dx,dz+R,dx,dy = \\iiint{S}\\left( \\frac{\\partial P}{\\partial x} + \\frac{\\partial Q}{\\partial y} + \\frac{\\partial R}{\\partial z} \\right) ,dV $$\n散度形式\r$$ {\\subset!\\supset} \\mathllap{\\iint}{S}\\vec{F},d\\vec{S}=\\iiint{S} \\mathrm{div},\\vec{F},dV $$\n证明\r任选一维，以 $z$/$R$ 方向为例\n对于该维，将闭合曲面分割成形如下图的形式，由此定义出 $S$，$S_{1}$，$S_{2}$，$S_{3}$，$D$\n于是 $$ \\begin{align} {\\subset!\\supset} \\mathllap{\\iint}{S}R,dx,dy \u0026amp; =\\iint{S_{1}+S_{2}+S_{3}}R,dx,dy \\ \u0026amp; =\\iint_{S_{1}}R,dx,dy+\\iint_{S_{2}}R,dx,dy+\\iint_{S_{3}}R,dx,dy \\ \u0026amp; =\\iint_{D}\\left( R_{S_{1}}-R_{S_{2}} \\right),dx,dy + 0\\ \u0026amp; =\\iint_{D}dR,dx,dy \\ \u0026amp; = \\int dx,dy, \\int_{S_{2}}^{S_{1}} \\frac{\\partial R}{\\partial z} , dz \\ \u0026amp; =\\iint_{D} \\frac{\\partial R}{\\partial z},dV \\end{align} $$ 其他两维同理，三维相加即为高斯公式\n","date":"2025-01-30T19:40:38+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86/%E9%AB%98%E6%96%AF%E5%85%AC%E5%BC%8F/","title":"高斯公式"},{"content":"第一型曲面积分\r特征\r类似\r曲线积分 \u0026gt; 第一型曲线积分\r：\n无向 具有保守性 形式\r$$ \\iint_{S}f(x,y,z),dS $$\n计算\r隐函数型\r已知 $$ z=z(x,y) $$ 则 $$ dS=\\sqrt{ 1+z_{x}^{2}+z_{y}^{2} },d\\delta $$ 即 $$ \\iint {S}f(x,y,z) , dS=\\iint{D}f(x,y,z(x,y))\\cdot\\sqrt{ 1+z_{x}^{2}+z_{y}^{2} },d\\delta $$ 其中 $D$ 显然是曲面在平面 $xOy$ 的投影\n参数型\r已知 $$ \\left{ \\begin{align} x \u0026amp; =x(u,v) \\ y \u0026amp; =y(u,v) \\ z \u0026amp; =z(u,v) \\end{align} \\right. $$ 则同\r曲面面积\r令 $$ \\left{ \\begin{align} E \u0026amp; =x_{u}^{2}+y_{u}^{2}+z_{u}^{2} \\ \\ F \u0026amp; =x_{u}x_{v}+y_{u}y_{v}+z_{u}z_{v}\\ \\ G \u0026amp; =x_{v}^{2}+y_{v}^{2}+z_{v}^{2} \\end{align} \\right. $$ 有 $$ dS=\\sqrt{ EG-F^{2} },du,dv $$ 即 $$ \\iint {S}f(x,y,z) , dS = \\iint{D}f(x(u,v),y(u,v),z(u,v))\\cdot \\sqrt{ EG-F^{2} },du,dv $$\n第二型曲面积分\r特征\r类似\r曲线积分 \u0026gt; 第二型曲线积分\r：\n有向 不一定具有保守性 形式\r向量型\r$$ \\iint_{S}\\vec{F}(x,y,z)\\cdot \\vec{n}(x,y,z),dS $$ 或者 $$ \\iint_{S}\\vec{F}(x,y,z),d\\vec{S} $$ 其中 $\\vec{n}$ 是 $dS$ 的单位法向量\n形象记忆\r可以将第二型曲面积分结合流量记忆\n这里 $\\vec{v}$ 就是 $\\vec{F}$\n分拆型\r同样还可以类似\r曲线积分 \u0026gt; 第二型曲线积分\r把向量函数拆成正常函数： $$ \\iint {S}\\vec{F}\\cdot \\vec{n},dS=\\iint{S}(P\\cdot \\cos\\alpha+Q\\cdot \\cos\\beta+R\\cdot \\cos\\gamma),dS $$ (因为高维第二性曲线积分物理意义不强，所以这里只写三维的第二型曲线积分拆分)\n而 $\\cos\\gamma,dS$ 明显具有几何意义，即 $dS$ 在平面 $xOy$ 上的有向投影(可正可负) 故分拆型第二性曲线积分可以进一步表达成： $$ \\iint_{S}P,dy,dz+Q,dx,dz+R,dx,dy $$\n计算\r转为第一型曲面积分\r根据 分拆型\r将第二型曲面积分分拆成第一型曲面积分即可计算。\n转为重积分\r$$ \\iint_{S}\\vec{F}\\cdot \\vec{n},dS=\\iint_{D} (-P\\cdot z_{x}-Q\\cdot z_{y}+R),d\\delta $$ 其中 $D$ 显然是曲面在平面 $xOy$ 的投影\n第二型曲面积分直接转为重积分推导\r记曲面具有隐函数型 $z=f(x,y)$\n则取微分得：$-f_{x},dx-f_{y},dy+dz=0$\n故单位法向量：$\\vec{n}=\\pm\\frac{1}{\\sqrt{ 1+f_{x}^{2}+f_{y}^{2} }}\\cdot(-f_{x},-f_{y},1)$\n所以根据向量运算：$\\iint {S}\\vec{F}\\cdot \\vec{n},dS=\\iint{S} \\pm\\frac{1}{\\sqrt{ 1+f_{x}^{2}+f_{y}^{2} }}(-P\\cdot f_{x}-Q\\cdot f_{y}+R),dS$\n又因为：$dS=\\sqrt{ 1+f_{x}^{2}+f_{y}^{2} },d\\delta$\n所以最终得出：$\\iint_{S}\\vec{F}\\cdot \\vec{n},dS=\\iint_{S} \\pm(-P\\cdot f_{x}-Q\\cdot f_{y}+R),d\\delta$\n以上 $\\pm$ 均规定为：当法向量向上($z\u0026gt;0$)时取正，向下时($z\u0026lt;0$)时取负\n参数型\r已知曲面 $S$ 由参数方程给出： $$ \\left{ \\begin{align} x \u0026amp; =x(u,v) \\ \\\ny \u0026amp; =y(u,v) \\ \\\nz \u0026amp; =z(u,v) \\end{align} \\right. , \\ (u,v) \\in D $$ 则：\n$S$ 上任一点法向量の方向余弦： $$ \\pm(\\cos\\alpha,\\cos\\beta,\\cos\\gamma)=\\pm \\frac{1}{\\sqrt{ EG-F^{2} }}(A,B,C) $$ 其中 $$ \\left{ \\begin{align} A \u0026amp; =\\frac{\\partial(y,z)}{\\partial(u,v)} \\ \\\nB \u0026amp; =\\frac{\\partial(x,z)}{\\partial(u,v)} \\ \\\nC \u0026amp; =\\frac{\\partial(x,y)}{\\partial(u,v)} \\end{align} \\right. $$\n而原第二型曲面积分可化为： $$ \\begin{align} \u0026amp; \\iint_{S}P,dx,dy+Q,dx,dz+R,dx,dy \\ = \u0026amp; \\iint_{D}\\left[\\ P(x(u,v),y(u,v),z(u,v))\\cdot A+Q(x(u,v),y(u,v),z(u,v))\\cdot B+R(x(u,v),y(u,v),z(u,v))\\cdot C \\ \\right],du,dv \\end{align} $$\n","date":"2025-01-12T17:15:11+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86/%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/","title":"曲面积分"},{"content":"第一型曲线积分\r第一型曲线积分通性\r重点在于曲线微分 $ds$ 的转换： $$ ds = \\sqrt{ dx_{1}^{2} + dx_{2}^{2} + \\dots + dx_{n}^{2} } $$\n特征\r无方向性 保守性 ($\\oint = 0$) 形式\r$$ \\int_{L}f(x_{1},x_{2},\\dots,x_{n})ds = \\int_{L}f(x_{1},x_{2},\\dots,x_{n}) \\cdot d\\left( \\sqrt{ \\left[ dx_{1} \\right] ^{2}+\\left[ dx_{2} \\right] ^{2} + \\dots + \\left[ dx_{n} \\right]^{2} } \\right) $$\n计算\r隐函数型\r$$ \\int_{L}f(x,y(x)),ds=\\int_{\\alpha}^{\\beta} f(x,y(x))\\cdot \\sqrt{ 1+\\left[ y\u0026rsquo;(x) \\right]^{2} } , dx $$\n曲线积分通性\r与文首提到的通性联系记忆：\n$$ \\begin{align} ds \u0026amp; =\\sqrt{ dx^{2}+dy^{2} } \\ \u0026amp; =\\sqrt{ dx^{2}+(y\u0026rsquo;(x)dx)^{2} } \\ \u0026amp; =\\sqrt{ 1+\\left[y\u0026rsquo;(x)\\right]^{2}},dx \\end{align} $$\n参数型\r已知\n$$ \\left{ \\begin{align} x \u0026amp; =x(t) \\ y \u0026amp; =y(t) \\end{align} \\right. $$\n则\n$$ \\int_{L}f(x(t),y(t))ds=\\int_{\\alpha}^{\\beta} f(x(t),y(t)) \\cdot \\sqrt{ \\left[ x\u0026rsquo;(t) \\right] ^{2}+\\left[ y\u0026rsquo;(t) \\right] ^{2} } , ds $$\n第二型曲线积分\r特征\r有向性 不一定具有保守性 ($\\oint\\neq 0$) 形式\r$$ \\int_{\\overset{\\frown}{AB}}\\vec{F}(x_{1},x_{2},\\dots,x_{n}),d\\vec{r}=\\int_{\\overset{\\frown}{AB}} F_{1}(x_{1},x_{2},\\dots,x_{n}),dx_{1}+F_{2}(x_{1},x_{2},\\dots,x_{n}),dx_{2}+\\dots+F_{n},(x_{1},x_{2},\\dots,x_{n}),dx_{n} $$\n计算\r参数型\r已知\n$$ \\left{ \\begin{align} x_{1} \u0026amp; =x_{1}(t) \\ x_{2} \u0026amp; =x_{2}(t) \\ \u0026amp; \\dots \\ x_{n} \u0026amp; =x_{n}(t) \\end{align} \\right. $$\n则\n$$ \\int_{\\overset{\\frown}{AB}}\\vec{F},d\\vec{r}=\\int_{\\overset{\\frown}{AB}}F_{1}\\cdot x_{1}\u0026rsquo;(t),dt+\\dots F_{n}\\cdot x_{n}\u0026rsquo;(t),dt $$\n仍然符合直觉上的微分运算，因此根据微分运算直觉记忆即可\n保守性\r前置知识：\r格林公式\r第二性曲线积分与路径无关条件 $\\iff$ $\\oint = 0$\n格林公式法：$\\forall(x,y)\\in D$ 都满足 $\\frac{\\partial Q}{\\partial x}=\\frac{\\partial P}{\\partial y}$ 原函数法：$\\exists F$ 满足 $dF=P,dx+Q,dy$ 凑原函数法 微分方程法 直接微分运算法 格林公式法的局限性\r格林公式法判定保守性的条件是四个等价命题中最严格的：\r🔗链接\r格林公式法只能用于单连通区域 原函数法可以用于单连通区域和多连通区域 北大版高数教材有给出在多联通区域使用格林公式法判定保守性导致错误的案例： 在区域 $D:0\u0026lt;\\delta\\leq x^{2}+y^{2}\\leq 4$ 积分 $$ \\oint_{L+} \\frac{-(x+y)}{x^{2}+y^{2}},dx+\\frac{x-y}{x^{2}+y^{2}},dy $$ 满足 $Q_{x} = P_{y}$，但是 $D$ 中的任意圆周 $C+$ 有 $\\oint_{C+}P,dx+Q,dy=2\\pi\\neq 0$\n","date":"2025-01-12T15:11:34+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86/%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86/","title":"曲线积分"},{"content":"\r注意\r这里是在重积分应用一章提到的曲面面积算法，只是部分的曲面积分知识\n推导\r结论\r已知 $$ \\left{ \\begin{align} x \u0026amp; =x(u,v) \\ y \u0026amp; =y(u,v) \\ z \u0026amp; =z(u,v) \\ \\end{align} \\right. $$ 令 $$ \\left{ \\begin{align} E \u0026amp; =x_{u}^{2}+y_{u}^{2}+z_{u}^{2} \\ F \u0026amp; =x_{u}x_{v}+y_{u}y_{v}+z_{u}z_{v} \\ G \u0026amp; =x_{v}^{2}+y_{v}^{2}+z_{v}^{2} \\ \\end{align} \\right. $$ 则 $$ dS=\\sqrt{ EG-F^{2} },du,dv $$\n","date":"2025-01-12T15:06:30+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86/%E6%9B%B2%E9%9D%A2%E9%9D%A2%E7%A7%AF/","title":"曲面面积"},{"content":"计算\r转换为累次积分： $$ \\iint_{D} f(x,y),dx,dy = \\int_{a}^{b} , dx \\int_{\\phi_{1}(x)}^{\\phi_{2}(x)} f(x,y) , dy $$\n坐标系转换\r","date":"2025-01-12T14:53:14+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86/%E9%87%8D%E7%A7%AF%E5%88%86/","title":"重积分"},{"content":"一阶线性常微分方程\r已知 $y\u0026rsquo;+P(x)\\cdot y=Q(x)$\n则 $y$ 的通解： $$ y=e^{-\\int P(x) , dx }\\cdot \\int e^{\\int P(x) , dx } \\cdot Q(x) , dx $$\n推导思路\r两边同乘 $e^{\\int P(x) , dx}$ 凑左边的 $\\left( y\\cdot e^{\\int P(x) , dx} \\right)\u0026rsquo;$，最后化简即可。\n伯努利方程\r已知 $y\u0026rsquo;+P(x)\\cdot y=Q(x)\\cdot y^{\\alpha}$\n则 $y$ 的通解为： $$ y^{1-\\alpha}=e^{-(1-\\alpha)\\int P_{x} , dx }\\cdot \\int e^{(1-\\alpha)\\int P(x) , dx }\\cdot(1-\\alpha) Q(x) , dx $$\n推导思路\r两边同除 $y^{\\alpha}$ 换元 $z=y^{1-\\alpha}$ 等价于求 $\\frac{1}{1-\\alpha}z\u0026rsquo;+P(x)\\cdot z=Q(x)$ 二阶常系数线性\r齐次\r形式\r$$ y\u0026rsquo;\u0026rsquo;+py\u0026rsquo;+qy=0 $$\n解的结构\r$$ y=C_{1}y_{1}+C_{2}y_{2} $$\n其中 $\\frac{y_{1}}{y_{2}}\\neq C$，线性无关\n通解\r特征方程：$r^2+p r+q=0$ 两根分别是 $r_{1}$ 和 $r_{2}$，两者相等时 $r=r_{1}=r_{2}$ 无实根时共轭复根记作 $\\alpha\\pm\\beta i$\n通解为： $$ y=\\left{ \\begin{align} \u0026amp; C_{1}e^{r_{1}x} + C_{2}e^{r_{2}x} \u0026amp; \\Delta=p^2-4q\u0026gt;0 \\ \\ \u0026amp; (C_{1}+C_{2}x)e^{rx} \u0026amp; \\Delta=p^2-4q=0 \\ \\ \u0026amp; e^{\\alpha x}(C_{1}\\cos\\beta x+C_{2}\\sin\\beta x) \u0026amp; \\Delta=p^2-4q\u0026lt;0 \\end{align} \\right. $$\n非齐次\r形式\r$$ y\u0026rsquo;\u0026rsquo;+py+q=f(x) $$\n解的结构\r通解\rTODO: 完成 常微分方程\r剩余笔记 📅 2025-04-28 ","date":"2025-01-03T15:29:41+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/","title":"常微分方程"},{"content":"\rhttps://zhuanlan.zhihu.com/p/33271753\r直接积分构造\r欲证 $\\phi(x)=0$\n则可构造函数 $F(x)=\\int \\phi (x) , dx$\n例子：柯西中值定理证明\r微分方程构造\r欲证 $\\phi(f\u0026rsquo;(x),f(x),x)=0$\n则可把 $\\phi(f\u0026rsquo;(x),f(x),x)=0$ 看成微分方程\n解出 $F(f(x),x)=0$ 作为构造函数\n注意\r可根据关键点选取对 $F(f(x),x)$ 同乘除 $u(x)$ 使关键点有意义\n🔗 2016·中山大学·高数I·期末考试·14\n例子\r已知 $f(x)$ 连续，$f(a)=f(b)=0$，求证 $\\exists \\epsilon \\in(a,b)$ s.t. $\\frac{f\u0026rsquo;(\\epsilon)}{-2\\epsilon}=f(\\epsilon)$.\n证：把 $\\frac{f\u0026rsquo;(\\epsilon)}{-2\\epsilon}=f(\\epsilon)$ 看成微分方程 $\\frac{y\u0026rsquo;}{-2x}=y$.\n$$ \\begin{align} \\frac{dy}{dx\\cdot(-2x)} \u0026amp; =y \\ \\frac{dy}{y} \u0026amp; =-2x,dx \\ \\ln y \u0026amp; =-x^{2}+C \\ y \u0026amp; =e^{-x^{2}+C} \\ y\\cdot e^{x^{2}}-C\u0026rsquo; \u0026amp; =0 \\end{align} $$\n则可以构造函数 $F(x)=f(x)\\cdot e^{x^{2}}$.\n由题：$F(a)=F(b)=0$\n所以由罗尔定理：$\\exists\\epsilon \\in(a,b)$ s.t. $F\u0026rsquo;(\\epsilon)=f\u0026rsquo;(\\epsilon)\\cdot e^{\\epsilon^{2}}+f(\\epsilon)\\cdot e^{\\epsilon^{2}}\\cdot 2\\epsilon=0$, i.e. $\\frac{f\u0026rsquo;(\\epsilon)}{-2\\epsilon}=f(\\epsilon)$\n常见瞪眼构造\r原形式 构造函数 $f\u0026rsquo;(x)g(x)+f(x)g\u0026rsquo;(x)$ $f(x)g(x)$ $f\u0026rsquo;(x)g(x)-f(x)g\u0026rsquo;(x)$ $\\frac{f(x)}{g(x)}$ $f\u0026rsquo;(x)+f(x)g\u0026rsquo;(x)$ $f(x)\\cdot e^{g(x)}$ ","date":"2024-12-31T13:31:36+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","title":"微分中值定理构造函数"},{"content":"曲线\r切线\r参数方程\r已知曲线 $$ \\left{ \\begin{align} x=x(t) \\ y=y(t) \\ z=z(t) \\end{align} \\right. $$ 则 $(x_{0},y_{0},z_{0})$ 处切线： $$ \\frac{x-x_{0}}{x\u0026rsquo;(t)}=\\frac{y-y_{0}}{y\u0026rsquo;(t)}=\\frac{z-z_{0}}{z\u0026rsquo;(t)} $$\n非参方程\r非参方程\r非参方程一般由两个曲面联立给出。\n含明显九种标准二次曲线型的一般可以参数方程化。\n已知曲线 $$ \\left{ \\begin{align} F(x,y,z)=0 \\ G(x,y,z)=0 \\end{align} \\right. $$ 则取微分： $$ \\left{ \\begin{align} F_{x},dx+F_{y},dy+F_{z},dz=0 \\ G_{x},dx+G_{y},dy+G_{z},dz=0 \\end{align} \\right. $$ 解得（运用\r克莱姆法则\r）： $$ \\left{ \\begin{align} \\frac{dy}{dx}=\\dots \\ \\frac{dz}{dx}=\\dots \\end{align} \\right. $$ 切线的法向量为 $\\left( 1, \\frac{dy}{dx}, \\frac{dz}{dx} \\right)$，切线为： $$ \\frac{x-x_{0}}{dx}=\\frac{y-y_{0}}{dy}=\\frac{z-z_{0}}{dz} $$\n法平面\r已知切线： $$ \\frac{x-x_{0}}{A}=\\frac{y-y_{0}}{B}=\\frac{z-z_{0}}{C} $$ 则发平面为： $$ A(x-x_{0})+B(y-y_{0})+C(z-z_{0})=0 $$\n曲面\r曲面的参数方程与非参方程\r与曲线刚好相反，曲面的非参方程可以直接给出\n切平面\r参数方程\r已知曲面： $$ \\left{ \\begin{align} x=x(u,v) \\ y=y(u,v) \\ z=z(u,v) \\end{align} \\right. $$ $$ \\vec{n}=\\frac{D(x,y,z)}{D(u,v)}=\\begin{array}{|} x-x_{0} \u0026amp; y-y_{0} \u0026amp; z-z_{0} \\ x_{u} \u0026amp; y_{u} \u0026amp; z_{u} \\ x_{v} \u0026amp; y_{v} \u0026amp; z_{v} \\end{array} $$ 根据法向量求切平面\n非参方程\r已知曲面： $$ F(x,y,z)=0 $$ 则 $(x_{0},y_{0},z_{0})$ 处的切平面为：\n$$ F_x\u0026rsquo;|{(x_0,y_0,z_0)}\\cdot(x-x_0)+F_y\u0026rsquo;|{(x_0,y_0,z_0)}\\cdot(y-y_0)+F_z\u0026rsquo;|_{(x_0,y_0,z_0)}\\cdot(z-z_0)=0 $$\n法线\r显然易得。\n","date":"2024-12-30T12:37:47+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86/%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95/","title":"多元微分几何"},{"content":"$$ \\int \\sin^{n} x , dx = -\\frac{1}{n}\\sin^{n-1}x \\cos x + \\frac{n-1}{n}\\int \\sin^{n-2}x , dx $$ $$ \\int cos^{n} x , dx =\\frac{1}{n}\\cos^{n-1}x\\sin x+\\frac{n-1}{n}\\int cos^{n-2}x, dx $$ $$ \\int \\tan^{n}x , dx = \\frac{\\tan^{n-1}x}{n-1} - \\int \\tan^{n-2}x , dx $$ $$ \\int \\cot^{n}x , dx = \\frac{\\cot^{n-1}x}{n-1} - \\int \\cot^{n-2}x,dx $$ $$ \\int \\sec^{n}x,dx=\\frac{1}{n-1}\\sec^{n-2}x\\tan x + \\frac{n-2}{n-1}\\int \\sec^{n-2}x,dx $$\n华里士公式\r根据前两个公式可以推出\r华里士公式\r。\n🔗 真题链接\r(2018·中大·期末考·高数·节选) 求 $\\int_{0}^{1} \\sqrt{1+x^2},dx$.\n法一(高阶三角函数降次)： $$\\begin{align} 原式 \u0026amp; =\\int_{0}^{1} \\sec x , d\\tan x \\ \u0026amp; =\\int_{0}^{\\frac{\\pi}{4}} \\sec ^{3}x , dx \\ \u0026amp; =\\frac{1}{2}\\sec x\\tan x\\left|{0}^{\\frac{\\pi}{4}}\\right.+\\int{0}^{\\frac{\\pi}{4}} \\sec x , dx \\ \u0026amp; =\\frac{\\sqrt{ 2 }}{2}+\\ln \\left| \\sec x+\\tan x \\right| \\left|_{0}^{\\frac{\\pi}{4}} \\right. \\ \u0026amp; =\\frac{\\sqrt{ 2 }}{2}+\\ln(\\sqrt{ 2 }+1) \\end{align}$$ 法二(配凑＋原积分重现)：\n","date":"2024-12-29T14:33:17+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%A7%AF%E5%88%86/%E9%AB%98%E9%98%B6%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E9%99%8D%E6%AC%A1/","title":"高阶三角函数积分降次"},{"content":"🔗 【不定积分】切比雪夫定理【无理函数积分】\r用途\r判定微式是否有初等函数积分。\n内容\r二项微式 $\\int x^{m}(a+bx^{n})^{p}dx$ 具有初等函数积分，当且仅当以下三种情形：\n$p \\in Z$ $\\frac{m+1}{n} \\in Z$ $\\frac{m+1}{n}+p \\in Z$ 换元方法见开头链接。\n注意\r有些积分表达式需要经过转化才能表现成二项微式，再运用切比雪夫定理判断可积性\n","date":"2024-12-27T15:44:29+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%A7%AF%E5%88%86/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E5%AE%9A%E7%90%86/","title":"切比雪夫定理"},{"content":"\r约定\r点 $P_{k}(x_{k},y_{k},z_{k})$ 线 $l_{k}:\\ \\frac{x-x_{k}}{m_{k}}=\\frac{y-y_{k}}{n_{k}}=\\frac{z-z_{k}}{p_{k}}$ 方向向量 $\\vec{v_{k}}=(m_{k},n_{k},p_{k})$ 直线上任一点 $A_{k} \\in l_{k}$ 面 $\\pi_{k}:\\ A_{k}x+B_{k}y+C_{k}z+D_{k}=0$ 法向量 $\\vec{n}=(A_{k},B_{k},C_{k})$ 平面上任一点 $Q_{k} \\in \\pi$ 投影：投影在 $Y$ 上的 $X$ 记作 $X\u0026rsquo;_{Y}$ abbr. $X'$ 点在线上投影：$P\u0026rsquo;_{l}(x\u0026rsquo;,y\u0026rsquo;,z\u0026rsquo;)$ 点在面上投影：$P\u0026rsquo;_{\\pi}(x\u0026rsquo;,y\u0026rsquo;,z\u0026rsquo;)$ 线在面上投影：$l\u0026rsquo;_{\\pi}:\\ \\frac{x-x\u0026rsquo;}{m\u0026rsquo;}=\\frac{y-y\u0026rsquo;}{n\u0026rsquo;}=\\frac{z-z\u0026rsquo;}{p\u0026rsquo;}$ 交集\r联立方程即可。\n线线：各分量相等 e.g. $\\frac{x-x_{1}}{m_{1}}=\\frac{x-x_{2}}{m_{2}}$ 线面：直线参数方程法 面面：主元法 距离\r点点：$d(P_{1},P_{2})=\\sqrt{ (x_{1}-x_{2})^2 + (y_{1}-y_{2})^2+(z_{1}-z_{2})^2 }$ 点线：$d(P,l)=\\frac{\\left| \\vec{AP}\\times \\vec{v} \\right|}{\\left| \\vec{v} \\right|}$ 点面：$d(P_{0},\\pi)=\\frac{\\left| Ax_{0}+By_{0}+Cz_{0}+D \\right|}{\\sqrt{ A^2+B^2+C^2 }}$ 线线：$d(l_{1},l_{2})=\\frac{\\left| \\vec{A_{1}A_{2}} \\cdot (\\vec{v_{1}}\\times\\vec{v_{2}}) \\right|}{\\left| \\vec{v_{1}}\\times \\vec{v_{2}} \\right|}$ 线面：$d(l_{0},\\pi)=\\frac{\\left| Ax_{0}+By_{0}+Cz_{0}+D \\right|}{\\sqrt{ A^2+B^2+C^2 }}$ 前提：线面平行 $\\leftrightarrow$ $Am_{0}+Bn_{0}+Cp_{0}=0$ 面面：$d(\\pi_{1},\\pi_{2})=\\frac{\\left| D_{1}-D_{2} \\right|}{\\sqrt{ A^2+B^2+C^2 }}$ 投影\r点点 点线：${P_{0}}\u0026rsquo;_{l}=A+\\frac{\\vec{AP}\\cdot \\vec{v}}{\\left| \\vec{v} \\right|^{2}}\\vec{v}$ 点面：${P_{0}}\u0026rsquo;_{\\pi}=Q+\\frac{\\vec{AP}\\cdot \\vec{n}}{\\left| \\vec{n} \\right|^{2}}\\vec{n}$ 线面：$\\vec{v\u0026rsquo;_{\\pi}}=\\vec{v}-\\frac{\\vec{v}\\cdot \\vec{n}}{\\left| \\vec{n} \\right|^{2}}\\vec{n}$ 标准点可取交点，用参数方程联立直线和平面 投影向量\r$\\vec{v}$ 在 $\\vec{n}$ 上的投影向量 $\\vec{v\u0026rsquo;_{\\vec{n}}}=\\frac{\\vec{v}\\cdot \\vec{n}}{\\left| \\vec{n} \\right|^{2}}\\vec{n}$\n","date":"2024-12-26T22:25:21+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%A9%BA%E9%97%B4%E5%87%A0%E4%BD%95%E7%82%B9%E7%BA%BF%E9%9D%A2/","title":"空间几何点线面"},{"content":"变换准则\r对于 $\\left( x_{1},x_{2},\\dots,x_{n} \\right) \\to (y_{1},y_{2},\\dots,y_{n})$\n且存在函数关系： $$ \\begin{align} x_{1}\u0026amp;=x_{1}(y_{1},y_{2},\\dots,y_{n}) \\ x_{2}\u0026amp;=x_{2}(y_{1},y_{2},\\dots,y_{n}) \\ \u0026amp;\\dots \\ x_{n}\u0026amp;=x_{n}(y_{1},y_{2},\\dots,y_{n}) \\end{align} $$ 则： $$ dx_{1}\\cdot dx_{2}\\cdot\\dots\\cdot dx_{n}=\\det J\\cdot dy_{1}\\cdot dy_{2}\\cdot\\dots\\cdot dy_{n} $$ 其中 $$ J=\\frac{D\\left( x_{1},x_{2},\\dots,x_{n} \\right) }{D\\left( y_{1},y_{2},\\dots,y_{n} \\right) } $$\n常见坐标变换\r温馨提醒\r以下坐标变换均为直角坐标系转为对应坐标系\n自由度 坐标系 转换形式 转换结果 雅可比行列式 二元 极坐标系 $(x,y)\\to(r,\\theta)$ $dx\\cdot dy=r\\cdot dr\\cdot d\\theta$ $\\det J=r$ 三元 柱坐标系 $(x,y,z)\\to(r,\\theta,z)$ $dx\\cdot dy\\cdot dz=r\\cdot dr\\cdot d\\theta\\cdot dz$ $\\det J=r$ 三元 球坐标系 $(x,y,z)\\to(\\rho,\\phi,\\theta)$ $dx\\cdot dy\\cdot dz=\\rho^{2}\\sin \\theta\\cdot d\\rho \\cdot d\\phi\\cdot d\\theta$ $\\det J=\\rho^{2}\\sin \\theta$ 球坐标系的 $\\phi$ vs. $\\theta$\r球坐标系中的 $\\phi$ 和 $\\theta$ 并不等价。\n方位角 $\\phi \\in \\left( 0,2\\pi \\right)$ $:=$ 坐标向量在 $xy$ 平面的投影与 $x$ 轴正方向的逆时针的偏移角 极角 $\\theta \\in \\left( 0, \\pi \\right)$ $:=$ 坐标向量与 $z$ 轴正方向的夹角 ","date":"2024-12-26T12:04:08+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86/%E9%87%8D%E7%A7%AF%E5%88%86%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/","title":"重积分坐标变换"},{"content":"🔗 真题\r(2021·中山大学·高等数学I·期末考试·节选) 已知 $g(x)=\\int_{0}^{1} f(tx) , dt$，求 $g\u0026rsquo;(x)$ .\n解答\r$$\\begin{align}g\u0026rsquo;(x)\u0026amp;=\\left( \\frac{1}{x} \\int_{0}^{x} f(tx) , dtx \\right)\u0026rsquo; \\\u0026amp;= -\\frac{1}{x^{2}}\\int_{0}^{x} f(u) , du + \\frac{f(x)}{x}\\end{align}$$\n方法论\r变限积分求导\r$$ (\\int_{\\phi_{1}(x)}^{\\phi_{2}(x)} f(t) , dt)\u0026rsquo; = f(\\phi_{2}(x))\\cdot \\phi_{2}\u0026rsquo;(x) - f(\\phi_{1}(x))\\cdot \\phi_{1}\u0026rsquo;(x) $$\n$$\n$$\n","date":"2024-12-26T10:50:57+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%A7%AF%E5%88%86/%E5%8F%98%E9%99%90%E7%A7%AF%E5%88%86/","title":"变限积分"},{"content":"\rhttps://zhuanlan.zhihu.com/p/370063904\r🔗 真题\r(2021·中山大学·高等数学I·期末考试) 证明 $\\lim_{ x \\to a }x^{3}=a^{3}$.\n解答\r法一 不妨 $\\left| x-a \\right|\u0026lt; \\frac{a}{2}$，则 $f(x)=\\left| x^{2}+a^{2}+ax \\right|\u0026lt;f\\left( \\frac{3}{2}a \\right)=\\frac{19}{4}a^{2}$. 则 $$\\begin{align}\\left| x^{3}-a^{3} \\right|\u0026amp;=\\left| x-a \\right|\\left| x^{2}+a^{2}+ax \\right|\\\u0026amp;\u0026lt;\\left| x-a \\right|\\cdot \\frac{19}{4}a^{2}\\\u0026amp;\u0026lt;\\epsilon\\end{align}$$ 所以只需取 $\\delta= \\mathrm{min} \\left{ \\frac{a}{2}, \\frac{4\\epsilon}{19a^{2}} \\right}$，即可 $\\forall \\epsilon\u0026gt;0$， $\\forall \\left| x-a \\right|\u0026lt;\\delta$，$\\left| x^3-a^3 \\right|\u0026lt;\\epsilon$.\n方法论\r不必一开始就找到 $\\delta$ 的取法，可以先对 $\\delta$ 假设一定值(第一前提)，然后根据后续不等式找到的临界点，取假定定值与临界点的 $\\mathrm{min}$ 作为 $\\delta$ 的取法。\n可以先对 $\\delta$ 假设一定值(第一前提)。 根据 第一前提 放缩，消去 $x$，转化为 $x_{0}$ / 其他定值。 最终转化为 $\\mathrm{const}\\ \\cdot \\ f(\\delta) \u0026lt; \\epsilon$ 的形式得出临界点。(最好是 $f(\\delta)=\\delta$) 将 $\\delta=\\mathrm{min}{ 第一前提，各临界点 }$ 作为取法 （实际上是第一前提区间与各临界区间的交集，产生的 $\\delta$ 取法） 现在我们再回顾真题的解答法一： 不妨 $\\left| x-a \\right|\u0026lt; \\frac{a}{2}$， (第一步：第一前提) 则 $f(x)=\\left| x^{2}+a^{2}+ax \\right|\u0026lt;f\\left( \\frac{3}{2}a \\right)=\\frac{19}{4}a^{2}$. （第二步：根据第一前提放缩，向定值靠拢） 则 $$\\begin{align}\\left| x^{3}-a^{3} \\right|\u0026amp;=\\left| x-a \\right|\\left| x^{2}+a^{2}+ax \\right|\\\u0026amp;\u0026lt;\\left| x-a \\right|\\cdot \\frac{19}{4}a^{2}\\\u0026amp;\u0026lt;\\epsilon\\end{align}$$ （第三步：得出临界点） 所以只需取 $\\delta= \\mathrm{min} \\left{ \\frac{a}{2}, \\frac{4\\epsilon}{19a^{2}} \\right}$，即可 $\\forall \\epsilon\u0026gt;0$， $\\forall \\left| x-a \\right|\u0026lt;\\delta$，$\\left| x^3-a^3 \\right|\u0026lt;\\epsilon$. （第四步：取临界点交集作为 $\\delta$ 取法）\n","date":"2024-12-26T10:33:22+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%AE%9A%E4%B9%89%E8%AF%81%E6%98%8E%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD%E6%80%A7/","title":"定义证明函数连续性"},{"content":"一言以蔽之：\n变量部分与主体部分相比是次量级 $\\Rightarrow$ 夹逼准则 变量部分与主体部分相比是同量级 $\\Rightarrow$ 可爱因子 ","date":"2024-12-26T10:14:49+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%8F%AF%E7%88%B1%E5%9B%A0%E5%AD%90%E4%B8%8E%E5%A4%B9%E9%80%BC%E5%87%86%E5%88%99%E7%9A%84%E9%80%89%E6%8B%A9/","title":"可爱因子与夹逼准则的选择"},{"content":"牢记以下几条法则： $$ x^{m}\\cdot o(x^{n})=o(x^{m+n}) $$ $$ o(x^{m})\\cdot o(x^{n})=o(x^{m+n}) $$ $$ o(x^{m})+o(x^{n})=o(x^{\\mathrm{min}{ m,n }}) \\ (x\\to 0) $$\n","date":"2024-12-25T23:13:47+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E9%AB%98%E9%98%B6%E6%97%A0%E7%A9%B7%E5%B0%8F%E8%BF%90%E7%AE%97/","title":"高阶无穷小运算"},{"content":" std::addressof 用于获得真实地址，无视 operator\u0026amp; 的重载。\n因此为了避免 operator\u0026amp; 重载问题，应该在移动函数判重中使用 std::addressof\n1 2 3 4 5 6 7 8 9 10 11 auto MyClass(Myclass\u0026amp;\u0026amp; another) noexcept { if (\u0026amp;another != this) { /* ... */ } // ill-formed if (std::addressof(another) != this) { // ok /* ... */ } return *this; } auto operator=(Myclass\u0026amp;\u0026amp; another) noexcept { /* ... */ } // 同理 ","date":"2024-12-21T00:17:14+08:00","permalink":"//localhost:1313/post/%E5%BC%80%E5%8F%91/cpp/addressof-%E4%B8%8E-%E7%A7%BB%E5%8A%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E8%B7%B5/","title":"addressof 与 移动函数实践"},{"content":"以下公式全部在 $x=0$ 处取得，省略 $\\lim_{ n \\to \\infty }$ .\n幂指对函数\r$$ e^x=1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+\\dots \\frac{x^n}{n!} $$ $$ \\ln(1+x)=x-\\frac{x^2}{2}+\\frac{x^3}{3}-\\dots+(-1)^{n+1} \\frac{x^n}{n} $$ $$ (1+x)^\\alpha=1+\\alpha x+\\frac{\\alpha(\\alpha-1)}{2!}x^2+\\dots+\\frac{A_{\\alpha}^n}{n!}x^n $$\n$$ \\frac{1}{1-x}=1+x+x^2+\\dots+x^n $$ $$ \\frac{1}{1+x}=1-x+x^2-\\dots+(-1)^{n}x^n $$\n三角函数\r$$ \\sin x=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\dots+(-1)^{n} \\frac{x^{2n+1}}{(2n+1)!} $$\n$$ \\cos x=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-\\dots+(-1)^n \\frac{x^{2n}}{(2n)!} $$ $$ \\tan x=x+\\frac{x^3}{3}+\\frac{2x^5}{15}+\\dots+\\frac{B_{2n}(-4)^n(1-4^n)}{(2n)!}x^{2n-1} $$ $$ \\arcsin x=x+\\frac{x^{3}}{6}+\\dots+\\frac{(2n-1)!!}{(2n)!!}\\cdot \\frac{x^{2n+1}}{2n+1} $$ $$ \\arctan x=x-\\frac{1}{3}x^3+\\frac{1}{5}x^5-\\dots+(-1)^n\\frac{x^{2n+1}}{2n+1} $$\n衍生等价代换无穷小\r用于乘积项快速代换。\n下式无特殊说明均为 $x\\to 0$ 时取得\n幂指对\r$$ \\begin{align} e^x \u0026amp;\\sim 1+x \\ \\\n\\ln(1+x)\u0026amp;\\sim x \\ \\\n\\ln x \u0026amp;\\sim x-1 (x\\to 1) \\ \\\n(1+x)^\\alpha \u0026amp;\\sim 1+\\alpha x \\ \\\n\\sqrt{1+x} \u0026amp;\\sim 1+\\frac{1}{2}x \\ \\\n\\end{align} $$\n三角\r$$ x \\sim \\sin x \\sim \\tan x \\sim \\arcsin x \\sim \\arctan x $$ $$ \\begin{align} \\sin x \u0026amp;\\sim x-\\frac{1}{6}x^3 \\ \\\n\\cos x \u0026amp;\\sim 1-\\frac{1}{2}x^2 \\ \\\n\\tan x \u0026amp;\\sim x+\\frac{1}{3}x^3 \\ \\\n\\end{align} $$\n","date":"2024-12-18T22:16:34+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%B8%B8%E8%A7%81%E4%B8%80%E5%85%83%E6%B3%B0%E5%8B%92/","title":"常见一元泰勒"},{"content":"不定型\r$\\frac{0}{0}$ 型 / $\\frac{\\infty}{\\infty}$ 型 / $0\\cdot \\infty$ 型 $\\Rightarrow$ 洛必达 幂指函数 $\\Rightarrow$ $a^{b}=e^{b\\ln a}=\\exp{ b\\ln a}$ $0^{\\infty}$ 型 $\\Rightarrow$ $\\exp{b\\ln a}$ $1^{\\infty}$ 型 $\\Rightarrow$ $\\exp{b\\ln a}=\\exp{b(a-1)}$ $\\infty-\\infty$ 型 $\\Rightarrow$ 有分母 $\\Rightarrow$ 通分 无分母 $\\Rightarrow$ 提公因式 泰勒展开 ","date":"2024-12-18T17:15:26+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90/","title":"函数极限"},{"content":"通式\r$$ f(x,y)=\\lim_{ n \\to \\infty } \\sum_{i=0}^{n} \\frac{ \\mathrm{d}^{n}f(x_{0},y_{0})}{n!} $$\n皮亚诺余项\r$$ f(x,y)=\\sum_{i=0}^{n} \\frac{ \\mathrm{d}^{n}f(x_{0},y_{0})}{n!}+o(\\rho^{n}) $$\n拉格朗日余项\r$$ f(x,y)=\\sum_{i=0}^{n} \\frac{ \\mathrm{d}^{n}f(x_{0},y_{0})}{n!}+\\frac{ \\mathrm{d}^{n+1}f(x_{0}+\\theta\\Delta x,y_{0}+\\theta\\Delta y)}{(n+1)!} $$\n特例：拉格朗日中值定理\r$$f(x,y)-f(x_{0},y_{0})=\\frac{ \\partial f }{ \\partial x } (x_{0}+\\theta\\Delta x,y_{0}+\\theta\\Delta y)\\Delta x+\\frac{ \\partial f }{ \\partial y }(x_{0}+\\theta\\Delta x,y_{0}+\\theta\\Delta y)\\Delta y$$\n","date":"2024-12-18T10:43:38+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86/%E5%A4%9A%E5%85%83%E6%B3%B0%E5%8B%92/","title":"多元泰勒"},{"content":"\r前情提要\rcursor 贵，想想用本地 ollama 是不是就不用付费了🤤\n本地\r主力机天选感觉应该带的动大模型，所以可以试试本地部署。\n安装 ollama\r1 scoop install ollama 配置 ollama 开机自启\r创建一个快捷方式，目标是 \u0026lt;path/to\u0026gt;/ollama.exe serve。\nWin+R，将快捷方式粘贴到 shell:startup 的路径下。\n配置模型\r1 2 olloma pull llama3.2 # olloma pull llama3.1:8b # 这个是 continue 官方推荐但是我没下 配置 continue\rvscode 安装 continue。\n在 continue 的 config.json 中添加：\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;models\u0026#34;: [ // ... { \u0026#34;title\u0026#34;: \u0026#34;Llama\u0026#34;, \u0026#34;provider\u0026#34;: \u0026#34;ollama\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;llama3.2\u0026#34; } ], // ... } 🔗更多模态：\nThen you are good to go ~ 🎉\n远程\r嘻嘻之前买的服务器派上用场了，远程部署一个在外面轻薄本 (还没买，有钱是遥遥无期) 也能用上 ollama。\nTODO: 尝试在服务器上部署一个 ollama (with docker)。📅 2025-07-01 ","date":"2024-12-17T18:12:13+08:00","permalink":"//localhost:1313/post/%E5%BC%80%E5%8F%91/%E6%9D%82%E8%AE%B0/%E9%83%A8%E7%BD%B2-ollama-and-vscode/","title":"部署 ollama + vscode"},{"content":"恒等变换\r位置：上弦中切下割 对角原则：六边形中对角乘积为 1 $\\sin x \\cdot \\csc x = 1$ $\\cos x \\cdot \\sec x = 1$ $\\tan x \\cdot \\cot x = 1$ 倒三角原则：阴影/倒三角的上二顶点平方和等于下顶点 $\\sin ^{2}x + \\cos ^{2}x = 1$ $\\tan ^{2}x + 1 = \\sec ^{2}x$ $\\cot ^{2}x + 1=\\csc ^{2}x$ 邻点原则：相邻顶点乘积等于当前顶点 $\\sin x = \\cos x \\cdot \\tan x$ $\\cos x = \\sin x\\cdot \\cot x$ $\\tan x=\\sin x\\cdot \\sec x$ $\\sec x=\\tan x\\cdot \\csc x$ $\\csc x=\\sec x\\cdot \\cot x$ $\\cot x=\\csc x\\cdot \\cos x$ 积分\r$\\sec ^{2}x=1+\\tan ^{2}x$ $\\sec ^{2}xdx=d\\tan x$ ","date":"2024-12-17T12:48:29+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/","title":"三角函数"},{"content":" ","date":"2024-12-13T15:02:51+08:00","permalink":"//localhost:1313/post/%E5%BC%80%E5%8F%91/vulkan/vulkan-project-examples/","title":"Vulkan Project Examples"},{"content":" 队列 Queue\r指令运行的场所。\n同一队列的指令按顺序执行。不同队列的指令不保证顺序，除非使用同步原语 (如 Semaphore )\n一个队列可以运行一种或多种指令：\n队列类型 命令类型 开始命令 Graphics Graphics Pipeline Commands vkCmdDraw* Compute Compute Pipeline Commands vkCmdDispath Transfer Transfer/Copy Commands vkCmdCopy Sparse Binding change the binding of sparse resources to memory vkQueueBindSparse 一般最老的支持 Vulkan API 的设备也会有至少一个同时有以上四种能力的队列。\n一个队列一次只能有一个线程提交。但是每个队列的提交可以同时进行。\n队列簇 Queue Family\r一个队列簇包含具有同样指令能力的多个队列。(类似于队列是实例，队列簇是类)\n","date":"2024-12-13T14:10:03+08:00","permalink":"//localhost:1313/post/%E5%BC%80%E5%8F%91/vulkan/vulkan-%E9%98%9F%E5%88%97/","title":"Vulkan 队列"},{"content":"备选方式\r不看 outdated 的方式，只看 modern C++ 的错误处理方式主要是以下几种：\n异常 exception std::expected\u0026lt;T, E\u0026gt; (since C++23 or with tl_expected) assert/panic 使用情景\r为了开销考虑，很有可能是无法 exclusively 选择其中一种的，需要按照错误发生的可能性进行特定选择。\n错误机制 运行开销 使用情景 exception 错误路径动态分配 默认避免使用异常以防开销，非常肯定出错无法解决就 noexcept，如果抛出就 crash 则与 assert 无差别 std::expected Error 空间分配开销 错误路径可能性大且倾向于可解决，如 io 错误 assert/panic 无 非常肯定出错无法解决 推荐策略\r在 modern c++ 可以避免使用 assert。assert 可以作为逻辑检查的补充。\n而在 exception 和 std::expected 的选择，可以顾名思义：\nexception：意料之外的错误，无法解决，抛出并最好 crash。概率在 1% 下时可以考虑。 std::expected：意料之中的错误，可以解决，显式处理。错误路径概率不低。 ","date":"2024-12-12T12:57:31+08:00","permalink":"//localhost:1313/post/%E5%BC%80%E5%8F%91/cpp/cpp-%E9%94%99%E8%AF%AF%E6%9C%BA%E5%88%B6/","title":"C++ 错误机制"},{"content":"前情提要\r我的 gui 项目原本是写成 headeronly + inline 的形式。但是转念一想我这个项目最低标准也是 C++20 ，索性一把梭哈只支持 module 的接口形式不就好了。\n而且一想想 headeronly 那一改的编译时长，比 static lib 慢得满地找牙。。更别提图形学部分之外还有对 Widget 的抽象，那真是 template 满天飞，以后规模大了改一下可以放肆摸鱼等编译了估计。(现在没啥规模改一下都要 4s 编译😅) 所以急迫需要模块加快编译速度 😭😭\n但考虑到智能提示对 module 落后的支持，我到现在才开始着手迁移到 module。\nC++ Module 笑话\rC++20 就已经有了 module，但是直到 2024 年的 clangd 19 才初步支持 module 的智能提示 (看 issue\r听起来是真的非常初步)，然后截至我开始写这篇文章 📅 2024-12-11，clang 19 还没支持 Windows (or just clangd, idk)。。。\n实践过程\rTODO: 把 ctrl 迁移到 C++ module 📅 2025-01-31 ✅ 2025-02-16 （慢慢等 Clang 19 什么时候在 Windows 上实装吧。。。）\n","date":"2024-12-11T23:51:35+08:00","permalink":"//localhost:1313/post/%E5%BC%80%E5%8F%91/cpp/%E8%BF%81%E7%A7%BB%E5%88%B0-cpp-module/","title":"迁移到 C++ Module"},{"content":"关系\r约定\r有箭头代表 tail 可以推出 head 没有箭头代表不一定可以推出对方\n一元\rgraph LR\r可微 ---\u003e 连续\r连续 ---\u003e 极限存在\r可导 \u003c---\u003e 可微\r可导 ---\u003e 连续\r可导 ---\u003e 极限存在\r多元\rgraph LR\r偏导数连续 ---\u003e 可微\r可微 ---\u003e 连续\r可微 ---\u003e 偏导数存在\r连续 ---\u003e 极限存在\r计算\r定点的偏导数：带入其他变量后再用极限求。 $$ f\u0026rsquo;x(0,0)=\\lim{x\\to 0}{\\frac{f(x,0)-f(0,0)}{x}} $$\n判断在某点是否可微：\n全微分连续 (偏导一定是所求点的偏导值，而不是偏导函数)：$$ \\lim_{\\Delta x \\to 0, \\Delta y \\to 0}{\\frac{\\Delta z - f\u0026rsquo;x(P{0}) \\cdot \\Delta x - f\u0026rsquo;y(P{0}) \\cdot \\Delta y}{\\sqrt{(\\Delta x)^2 + (\\Delta y)^2}}} = 0$$ 偏导数连续 对于初等函数，偏导数存在就一定可微，但不一定偏导数连续 比如 $(x^2+y^2)\\sin \\frac{1}{\\sqrt{ x^2+y^2 }}$ 在原点处就偏导数存在，可微。但是他在原点的偏导数不连续。 而且注意一定是初等函数，分段函数就不能看做初等！！ e.g. $f(x,y)=\\left{ \\begin{align} \u0026amp; \\frac{\\left|xy\\right|^{\\frac{3}{2}}}{x^2+y^2} \u0026amp; (x,y)\\neq(0,0) \\ \u0026amp; 0 \u0026amp; (x,y)=(0,0) \\end{align} \\right.$ 就不能看做初等函数，连续性和偏导数存在性不等同。 多元函数微分：$d(f(x_{1},\\dots,x_{n}))=\\sum_{i=1}^{n} \\frac{\\partial f}{\\partial x_{i}},dx_{i}$\n","date":"2024-12-11T11:38:13+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0-%E5%81%8F%E5%AF%BC-%E5%BE%AE%E5%88%86/","title":"多元函数 偏导 微分"},{"content":"候选名单\r1 xrepo search benchmark 找到以下几个候选库：\n谷歌大厂出品，但是不出意料有臭臭の宏。。\n9 months ago\u0026hellip; 估计死透了吧这库，还是 C++11 的，感觉已经可以放弃了 (logo 还挺萌的)\n支持到 C++20，seems promising。但是 example 里直接写 lambda 感觉不是很模块化，况且 lambda capture by reference 感觉也有性能误差问题。。之后详细看看\n到 C++17，至少微 modern。而且打了 lightweight high-performance 的标签 (在抢 nano 的饭碗吗阿喂) 感觉可以一试\n试试看！\rTest cpp benchmarking tools 🔽 📅 2024-12-22 ","date":"2024-12-10T23:15:57+08:00","permalink":"//localhost:1313/post/%E5%BC%80%E5%8F%91/cpp/cpp-benchmarking/","title":"C++ Benchmarking"},{"content":" (疑似 mq 白？)\n博客中另外提到的好用工具：\ncppinsights\r用于查看编译器处理 C++ 语法之后的代码。 quick-bench\r对比测试 C++ 代码效率。 build-bench\r对比测试 C++ 代码效率，用法比前面的简单。 ","date":"2024-12-10T22:57:25+08:00","permalink":"//localhost:1313/post/%E5%BC%80%E5%8F%91/cpp/cpp-%E8%B0%83%E4%BC%98%E9%AA%8C%E8%AF%81%E5%B7%A5%E5%85%B7/","title":"C++ 调优验证工具"},{"content":"本地生成 SSH key\r1 ssh-keygen -t rsa -b 4096 -C \u0026#34;dvdbr3o@qq.com\u0026#34;` enter 到底。如果需要 passphrase 可以设置一下。\n注意\r在每个不同设备，以及每个相同设备的相同设备的不同平台 (如 Windows 和 WSL)，都必须注册相应的 ssh key。\n登记到 github\r直接到 https://github.com/settings/keys\r进行 add SSH keys.\n1 cat ~/.ssh/id_rsa.pub 将内容复制到 SSH key 里就好了。\nSSH 授权\r1 2 ssh -T git@github.com 输入 yes 。\n设置用户名和邮箱\r1 git config --global user.name \u0026#34;dvdbr3o\u0026#34; git config --global user.email \u0026#34;dvdbr3o@qq.com\u0026#34; 克隆！\r现在选择 SSH 方式进行本地克隆吧~\n","date":"2024-12-09T19:28:30+08:00","permalink":"//localhost:1313/post/%E5%BC%80%E5%8F%91/%E6%9D%82%E8%AE%B0/ssh-at-github-%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/","title":"SSH @ github 快速配置指南"},{"content":"\rWarning\r因为不太可能有人像我一样傻买个国产平板搭 termux 环境打代码，所以本篇语言不会很干练，更像吐槽 :)\nTLDR: 最后失败了，别想着在 arm 架构的平板上搭开发环境😭😭\n前情提要\r咱就是说勒紧裤头攒钱买了个平板，想着游戏本续航是根本带不到课室的，一个平板又能无纸化，又能 termux 敲代码，还能画个画啥的。结果 termux 面对 ColorOS 当场碰壁，详见 archlinux @ termux @ ColorOS\r。没错，ColorOS 的 termux 一直处于瘫痪状态。经过 ColorOS 15 后的第二次更新，OnePlus Pad Pro 终于不会再一直在你安装包的时候弹窗还删你包了 🎉\n美中不足是 ColorOS (或者说所有 Android 14+？) 权限越缩越紧，导致 lspci 会被 Permission Denied。从而就导致一大批 Wayland Compositor 没办法在 unrooted termux 上运行。。（NO~ 我的 Hyprland 😭😭）\n你知道的，我勒紧裤头才省钱省出来买个平板，不想随随便便 root，真怕变板砖。。。所以只好委屈一下用 x11 的 window manger 了。。为了避免太多 hacking，最终选定了比较成熟的 KDE。\n安装 termux \u0026amp; archlinux\r因为 xfce 不是很好看，也不太好定制，所以后面管关于 vnc 和 xfce4 的部分不看，转而使用 kde plasma 和更新更好的 termux-x11。\n安装 KDE Plasma\r1 yay -S plasma-meta 然后在 termux 下写个快捷脚本，借鉴 https://github.com/LinuxDroidMaster/Termux-Desktops/blob/main/scripts/proot_arch/startkde_arch.sh\r：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/data/data/com.termux/files/usr/bin/bash # Kill open X11 processes kill -9 $(pgrep -f \u0026#34;termux.x11\u0026#34;) 2\u0026gt;/dev/null # Enable PulseAudio over Network pulseaudio --start --load=\u0026#34;module-native-protocol-tcp auth-ip-acl=127.0.0.1 auth-anonymous=1\u0026#34; --exit-idle-time=-1 # Prepare termux-x11 session export XDG_RUNTIME_DIR=${TMPDIR} termux-x11 :1 \u0026gt;/dev/null \u0026amp; # Wait a bit until termux-x11 gets started. sleep 3 # Launch Termux X11 main activity am start --user 0 -n com.termux.x11/com.termux.x11.MainActivity \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 sleep 1 # Login in PRoot Environment. Do some initialization for PulseAudio, /tmp directory # and run KDE as user droidmaster. # See also: https://github.com/termux/proot-distro # Argument -- acts as terminator of proot-distro login options processing. # All arguments behind it would not be treated as options of PRoot Distro. proot-distro login archlinux --shared-tmp -- /bin/bash -c \u0026#39;export PULSE_SERVER=127.0.0.1 \u0026amp;\u0026amp; export XDG_RUNTIME_DIR=${TMPDIR} \u0026amp;\u0026amp; su - dvdbr3o -c \u0026#34;DISPLAY=:1 dbus-launch startplasma-x11\u0026#34;\u0026#39; exit 0 然后用这个脚本进 arch 就可以看到 KDE 了！！\n修改分辨率\r默认分辨率是 3000x15__，忘了，但是不重要，这么宽，这么大的分辨率在我平板上我怎么看？而且它还强制默认只有这一种分辨率。。所以要手动缩小分辨率，用到 xrandr。\n不知道是啥蜜汁问题，startplasma-x11 进系统竟然没有加载 ~/.xprofile / ~/.xsession / ~/.xinitrc ？？浪费我一下午时间 😅 问我为什么不用 /etc/profile？要是 profile 在 kde 之后执行那我能不乐意😅 但想想就是不可能，必须找个能在 plasma 启动后的 startup script 方案。\n最后解决方案是用 kde-workspace。在 ~/.config/plasma-workspace/env/ 下的脚本都会在 plasma 启动后执行。于是在 ~/.config/plasma-workspace/env/display.sh：\n1 2 3 4 5 6 7 8 #!/bin/bash # Display Resolution xrandr --newmode \u0026#34;1920x1080_60.00\u0026#34; 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync xrandr --newmode \u0026#34;1280x768_60.00\u0026#34; 79.50 1280 1344 1472 1664 768 771 781 798 -hsync +vsync xrandr --addmode \u0026#34;Builtin Display\u0026#34; \u0026#34;1920x1080_60.00\u0026#34; xrandr --addmode \u0026#34;Builtin Display\u0026#34; \u0026#34;1280x768_60.00\u0026#34; xrandr --output \u0026#34;Builtin Display\u0026#34; --mode \u0026#34;1920x1080_60.00\u0026#34; 最后发现 termux-x11 设置里 Output \u0026gt; Display resolution mode 改为 exact 并指定分辨率好像就可以解决。。。😅\n浪费了周末的一个下午。。😭😭😭😭\n中文支持\r前面的 blog 提到了本地化而且讲的很清楚，但是要注意的是一定要先下一个中文字体，否则中文还是都是问号乱码：\n1 yay -S ttf-harmonyos-sans # 鸿蒙一般般，但是它字体确实好看 （话说本来还想在 ColorOS 也全局用 HarmonyOS Sans，这何尝不是一种 NTR，结果你懂的，什么叫做主题商店啊😅）\nTODO: 今晚好晚了，明天还要上课，现在先去洗澡。还有好多好多美化工作，最后还有重量级就是看能不能支持 Vulkan 开发了。。。要是不能我还不如直接买个轻薄本，买个 Surface Book 不比平板好？但不管怎么说游戏本性能不如台式机，还不能承担笔记本功能的逆天事实已经被证实了。。。到底是谁在怂恿我买游戏本啊啊啊啊啊😤😤 🛫 2024-12-08 ✅ 2024-12-09 鼠标 ＆ 触控板支持\r平板 TouchPad 感觉不是很顺手，双指滑动没有预期的 scroll 操作。而且按键盘上的搜索键 plasma 提示 Touchpad off，明显是收到了 keycode 但是 Touchpad 或者 Keyboard 哪里设置不正常。自然想到去 System Settings \u0026gt; Mouse \u0026amp; Touchpad 排查，但是竟然闪退了？？查看 log 定位到是 xcb_mouse: unable to select appropriate backend，应该是 xinput 的锅。但是调用 xinput list 输出的 device list 看起来却很正常，又有 Mouse 又有 Touchpad 。。。\n找不到解决方案。。感觉是权限问题。不管了。。。\n输入法\r用 fctix5 。\n主题\r动态壁纸\rvscode\r1 yay -S visual-studio-code-bin Vulkan\r屁嘞，我在想什么。。首先基于 vnc 的方案屏幕那么卡我搞个蛋的图形学。。其次权限这么严怎么可能 gpu passthrough。。最后，你平板是 arm 架构连 clangd 都装不上 😅😅😅 我 ctrl 那么依赖模板没有 language server 我怎么活？？心累，，随时随地开发 Vulkan 的梦破灭了。。。vulkan 的开发门槛还挺高的，，这平板只能拿来写写 server 或者前端了。。。打代码也用不上 termux 那么完全的环境，那屏幕投影卡的不如原生的阉割版 vscode 的 Marscode Web IDE 啊啊。。但是哪怕是写 server 和前端 Marscode 体验也比 termux-x11 好啊 😭😭 白买了白买了。。\n总结\r大家千万别以为平板可以当生产力工具，尤其是 unrooted pads。。 有打代码需求老老实实买个轻薄本，装 windows (with wsl2)，特别是避开 arm 架构 QAQ 现在已经改变方向了，准备入手一台二合一笔记本，就是不知道手写笔+Obsidian 在 Windows 上体验如何。目前看中的是 xiaomi book air 13，生态什么的已经无所谓了，能在宿舍外打 vulkan 已经很满足了 QAQ\n","date":"2024-12-08T16:42:04+08:00","permalink":"//localhost:1313/post/%E5%BC%80%E5%8F%91/%E6%9D%82%E8%AE%B0/kde-archlinux-termux-%E5%AE%89%E8%A3%85%E7%BE%8E%E5%8C%96%E4%B9%8B%E8%B7%AF/","title":"KDE + Archlinux @ Termux 安装美化之路"},{"content":"隐函数存在定理\r$$ \\frac{\\partial{y}}{\\partial{x}} = - \\frac{F\u0026rsquo;_x}{F\u0026rsquo;_y} $$ 分数有意义时存在隐函数关系。\ndz 与 df 的区别\r$\\frac{\\partial{z}}{\\partial{x}}$ $\\Rightarrow$ 要考虑链式关系/隐函数关系的，简写成 $z_x$ $\\frac{\\partial{f}}{\\partial{x}}$ $\\Rightarrow$ 把各变量看做无关变量，简写成 $f\u0026rsquo;_x$ 或者 $f_x$ 高阶偏导\r高次偏导应该把前项看成函数而非变量。 例如 $\\frac{\\partial^{2}z}{\\partial x^{2}}=\\frac{\\partial}{\\partial x}\\left( \\frac{\\partial z}{\\partial x} \\right)$, 其中的 $\\frac{\\partial z}{\\partial x}$ 就是一个函数而非变量，进行二阶偏导时把 $z$ 外的其他变量看作无关变量。\n","date":"2024-12-05T15:03:08+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86/%E9%9A%90%E5%87%BD%E6%95%B0%E5%AD%98%E5%9C%A8%E5%AE%9A%E7%90%86/","title":"隐函数存在定理"},{"content":"积分中值定理\r已知：$f(x)$ 在 $[a,b]$ 上连续\n结论：$\\int_a^b f(x)\\ dx=f(\\xi)(b-a)$\nAttention\r这是一个在课本里就有的结论，无需证明\n积分中值定理推广\r已知：$f(x)$，$g(x)$ 在 $[a, b]$ 上连续，$g(x)$ 在 $[a, b]$ 上不变号\n结论：$\\int_{a}^{b} f(x)g(x) , dx = f(\\xi)\\int_{a}^{b} g(x) , dx$\n证明：对 $\\int_{a}^{b} f(x)g(x) , dx$ 和 $\\int_{a}^{b} g(x) , dx$ 应用柯西中值定理\n","date":"2024-12-02T11:34:09+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%A7%AF%E5%88%86/%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/","title":"中值定理"},{"content":"Floyd\r核心逻辑：\n1 2 3 4 for (auto k = 1; k \u0026lt;= n; ++k) for (auto x = 1; x \u0026lt;= n; ++x) for (auto y = 1; y \u0026lt;= n; ++y) f[x][y] = std::min(f[x][y], f[x][k] + f[k][y]); 时间复杂度 $O(n^3)$，空间复杂度 $O(n^2)$\nBellman-Ford\r用途\r处理有负权边的单源最短路，作为负权边图 dijkstra 的替代方案。\n时间复杂度 $O(mn)$。\n实现\r判负环\r🔗 洛谷 P3385 【模板】负环\rSPFA\r用途\r优先队列优化 Bellman-Ford 时间复杂度。\n时间复杂度\n实现\rDijkstra\r被证明普遍最优了 :)\n用途\r求解 非负权图 上单源最短路径\n实现\r将所有点分为 已经确定最短路点集 $S$ (vis[u] = true) 和 未确定最短路点集 $T$ (vis[u] = false])。\n初始化源点 $s$ 有 $dis(s) = 0$，其他 $dis(u) = +\\infty$\n然后重复操作：\n从 $T$ 取最短路长度最小的点，移到 $S$ 对刚刚被加进 $S$ 的点所有出边进行松弛 $T$ 为空时结束。\n暴力\r1 // TODO: 优先队列优化\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 template\u0026lt;typename T = unsigned long long\u0026gt; struct DijkstraGraph { struct Node { size_t u; T dis; friend auto operator\u0026lt;(const Node\u0026amp; lhs, const Node\u0026amp; rhs) -\u0026gt; bool { return lhs.dis \u0026lt; rhs.dis; } }; struct Edge { size_t to; T dis; }; size_t size; std::vector\u0026lt;std::forward_list\u0026lt;T\u0026gt;\u0026gt; edges; std::vector\u0026lt;T\u0026gt; dis; std::vector\u0026lt;bool\u0026gt; vis; explicit DijkstraGraph(size_t n) : size(n), edges(n + 1), dis(n + 1, std::numeric_limits\u0026lt;T\u0026gt;::max()), vis(n + 1, false) {} // add_edges(...) // ... auto dijkstra(size_t s) -\u0026gt; void { std::priority_queue\u0026lt;Node, std::vector\u0026lt;Node\u0026gt;, std::greater\u0026lt;Node\u0026gt;\u0026gt; q; // subset of $T$ dis[s] = 0; q.push({ s, dis[s] }); while (!q.empty()) { auto u = q.top().u; q.pop(); if (vis[u]) continue; vis[u] = true; for (const auto\u0026amp; e : edges[u]) if (dis[e.to] \u0026gt; dis[u] + e.dis) { dis[e.to] = dis[u] + e.dis; q.push({ e.to, dis[e.to] }); } } } }; 时间复杂度 $O(m\\log{m})$。\nJhonson 全源最短路\r用途\r任意图 の 全源最短路\n实现\r为解决负权边，对边重新标注：\n$$ w\u0026rsquo; = w + h_u - h_v $$\n联想势能进行记忆。\n其中 $h_u$ 是零势能面(节点0) 到节点 $u$ 的最短路。\nTODO：完成 # P5905 【模板】全源最短路（Johnson）\r🔽 📅 2024-12-06 ","date":"2024-11-29T16:16:01+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/","title":"最短路"},{"content":" 图\r点/边\r图是一个二元集合组：$G = (V(G), E(G))$\n$V(G)$ $:=$ 点集 (vertex set) $\\forall v \\in V(G)$ $:=$ 顶点(vertex)/节点(node) $\\left| V(G) \\right|$ $:=$ 阶 (order) $E(G)$ $:=$ 边集 (edge set) 无向边(undirected edge)：$\\forall e \\in E(G)$，$e = (u,v)$ 无序 有向边(directed edge)/弧(arc)：$\\forall e \\in E(G)$，$e = (u,v)$ 有序，aka $e = u \\to v$ 其中 $u$ $:=$ 起点(tail) 其中 $v$ $:=$ 终点(head) 若边有权，则图为赋权图。权全为正实数，则图为正权图 为什么起点是 tail，终点是 head？\r因为边通常用箭头表示，而箭头是从「尾」指向「头」的。\n相邻\r在无向图 $G = (V, E)$ 中\n边点关联/相邻：$\\mathrm{adjacent(e,v)}$ / $\\mathrm{incident}(e, v)$ $:=$ $\\exists \\ e = (u, v) \\in E$\n点点相邻：$\\mathrm{adjecent}(u,v) := \\exists \\ e = (u,v) \\in E$\n单点邻域：$N(v) := { u \\in V \\ | \\ \\mathrm{adjacent(u,v)} }$\n点集邻域：$N(S) := \\bigcup\\limits_{v \\in V} N(v)$\n","date":"2024-11-29T15:53:57+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E8%AE%BA%E6%A6%82%E5%BF%B5/","title":"图论概念"},{"content":"主要有两种同步原语：\nFence 栅栏：用于 应用程序 $\\Leftrightarrow$ 渲染 Semaphore 信号量：用于 指令队列内/指令队列间 の 指令间 ","date":"2024-11-28T11:28:03+08:00","permalink":"//localhost:1313/post/%E5%BC%80%E5%8F%91/vulkan/vulkan-%E5%90%8C%E6%AD%A5/","title":"Vulkan 同步"},{"content":"定义\r满足以下功能的树状数组结构：\n单点修改 区间查询 满足以下特征： 代码量小 维护的信息 \u0026amp; 运算满足： 结合律：$(x \\circ y) \\circ z = x \\circ (y \\circ z)$ 可差分：运算具有逆运算，已知 $x \\circ y$ 和 $y$ 可推 $x$。 用途\r单点修改，区间查询\n实现\r结构\r对于给定数据数组 $a[n]$ ，树状数组提供缓存数组 $c[n]$ 缓存区间信息。\n$c[i]$ 的管辖区间应为 $[i + \\mathrm{lowbit}(i) .. i]$，即： $$ c[i] = \\mathrm{opt}{a[i - \\mathrm{lowbit}(i) + 1 .. i]} $$\nLowbit\r$\\mathrm{lowbit}$ 运算是指一个数只保留在二进制下最低位的 1 ，其余位为 0 所构成的二进制数。\n根据二进制知识有：\n1 auto lowbit(int x) -\u0026gt; int{ return x \u0026amp; -x; } 区间查询结果根据缓存信息结合构成，因此要求结合律。\nTODO：由于线段树能够全包含且大于树状数组的适用范围，且 树状数组 相对 线段树 占优仅在于部分场景的时间复杂度常数系数，所以优先学线段树，树状数组有空再来看 🔽 ","date":"2024-11-27T12:46:42+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","title":"树状数组"},{"content":"\n$$ \\int_{0}^{\\frac{\\pi}{2}} \\sin ^{n}x , dx=\\int_{0}^{\\frac{\\pi}2{}}\\cos ^{n}x , dx=\\left{ \\begin{align} \u0026amp;\\frac{(n-1)!!}{n!!}\u0026amp; (n为奇) \\ \u0026amp;\\frac{(n-1)}{n!!}\\cdot \\frac{\\pi}{2}\u0026amp;(n为偶) \\end{align} \\right. $$ $$ \\int_{0}^{\\pi} \\sin ^{n} x , dx = 2\\cdot \\int_{0}^{\\frac{\\pi}{2}} \\sin ^{n}x , dx $$ $$ \\int_{0}^{\\pi} \\cos ^{n}x , dx =\\left{ \\begin{align} \u0026amp; 0 \u0026amp; (n为奇) \\ \u0026amp; 2\\cdot \\int_{0}^{\\frac{\\pi}{2}} \\cos ^{n}x , dx \u0026amp; (n为偶) \\end{align} \\right. $$ $$ \\int_{0}^{2\\pi} \\sin ^{n}x , dx =\\int_{0}^{2\\pi} \\cos ^{n}x , dx=\\left{ \\begin{align} \u0026amp; 0 \u0026amp; (n为奇) \\ \u0026amp; 4\\cdot \\int_{0}^{\\frac{\\pi}{2}} \\sin ^{n} , dx \u0026amp; (n为偶) \\end{align} \\right.\n$$\n提示\r根据函数图像的正负形记忆是 0 还是 $k\\cdot \\int_{0}^{\\frac{\\pi}{2}} \\sin ^{n}x , dx$\n","date":"2024-11-27T11:46:59+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%A7%AF%E5%88%86/%E5%8D%8E%E9%87%8C%E5%A3%AB%E5%85%AC%E5%BC%8F/","title":"华里士公式"},{"content":"定义\r一个二维表 $f(i, j)$。\n其中 $f(i, j)$ 表示区间 $\\mathrm{op}{[i .. i + 2^j - 1]}$。\n原理\r由定义显然有状态方程：$f(i, j) = \\mathrm{op}{ f(i, j - 1), f(i + 2^{j - 1}, j - 1) }$\n查询时：$\\mathrm{op}{[l .. r]} = \\mathrm{op} { \\mathrm{op}{[l .. l + 2^s - 1]}, \\mathrm{op}{[r - 2^s + 1 .. r]} } = \\mathrm{op}{f(l, s), f(r - 2^s + 1, s)}$ ，其中 $s = \\lfloor{\\log_2{(r - l + 1)}}\\rfloor$。\n用途\r解决 可重复贡献问题。\n可重复贡献问题\r指只包含运算符 $\\mathrm{op}$ 操作的区间问题，其中 $\\mathrm{op}$ 满足 $x \\ \\mathrm{op} \\ x = x$。 例如：\nRMQ 问题 (区间最值问题)：$\\max(x, x) = x$ 区间 GCD 问题：$\\gcd(x, x) = x$ 时间复杂度：\n预处理 $O(n \\log{n})$。 查询 $O(1)$。 离线，不支持增添数据。\n实现\r结构\r1 2 3 4 5 6 7 8 template\u0026lt;typename T\u0026gt; struct SparseTable { using ST = std::vector\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt;; using Op = std::function\u0026lt;T(const T\u0026amp;, const T\u0026amp;)\u0026gt;; ST st; Op op; }; 初始化\r1 2 3 4 5 6 7 8 9 10 11 12 13 SparseTable(const std::vector\u0026lt;T\u0026gt;\u0026amp; t, Op op) : op(op) { using std::ceil; using std::log2; auto n = t.size(); std::size_t s = ceil(log2(n)) + 1; st.assign(n, std::vector\u0026lt;T\u0026gt;(s)); for (int i = 0; i \u0026lt; n; ++i) st[i][0] = t[i]; for (int j = 1; j \u0026lt; s; ++j) { auto pj = 1 \u0026lt;\u0026lt; (j - 1); // power of j for (int i = 0; i + pj \u0026lt; n; ++i) st[i][j] = op(st[i][j - 1], st[i + pj][j - 1]); } } 查询\r1 2 3 4 5 6 7 8 auto SparseTable::query(std::size_t l, std::size_t r) const -\u0026gt; const T\u0026amp; { using std::floor; using std::log2; { --l, --r; } // 如果是 1~n 序号 std::size_t s = floor(log2(r - l + 1)); return op(st[l][s], st[r - (1 \u0026lt;\u0026lt; s) + 1][s]); } ","date":"2024-11-26T17:23:39+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/st-%E8%A1%A8/","title":"ST 表"},{"content":"一次项\r对于分解式的一次项及其任意幂 $$ \\frac{P(x)}{Q(x)} = \\sum_{i = 1}^{n}\\sum_{j = 1}^{m}{\\frac{A_{ij}}{(x-b_i)^j}} $$ 每一项系数可如下分解： $$ A_{i1} = \\lim_{x \\rightarrow b_i}{(x - b_i) \\cdot \\frac{P(x)}{Q(x)}} $$ 更一般的高次形式： $$ A_{ij} = \\frac{1}{(m-j)!} \\lim_{x \\rightarrow b_i}{\\frac{d^{(m-j)}}{dx^{(m-j)}}\\left( \\frac{P(x)}{Q(x)} \\cdot \\left( x-b_{i} \\right) ^{m} \\right) } $$\n二次项\r常规方法\r待定系数。在一次项已知系数的情况下用待定系数难度降低。\n复变速算\r对于含二次项 $x^2+px+q$ ($\\Delta=p^2-4q\u0026lt;0$) 分母的有理式：\n待定系数 两边同乘二次项，把二次项移到分子 带入二次项复根 对比实部虚部得出系数 (例子·2019·考研·高数) 分解有理式 $\\frac{3x+6}{(x-1)^2(x^2+x+1)}$ 记 $x^2+x+1=0$ 的一个实根为 $x_{0}=-\\frac{1}{2}+\\frac{\\sqrt{ 3 }}{2}i$ 则有 $x_{0}^2+x_{0}+1=0$ $$ \\begin{align} \\frac{3x+6}{(x-1)^2(x^2+x+1)}\u0026amp;=\\frac{A_{1}}{x-1}+\\frac{A_{2}}{(x-1)^2}+\\frac{Mx+N}{x^2+x+1} \\ \\frac{3x+6}{(x-1)^2(x^2+x+1)}\u0026amp;=\\frac{-2}{x-1}+\\frac{3}{(x-1)^2}+\\frac{Mx+N}{x^2+x+1} \\ \\frac{3x+6}{(x-1)^2}\u0026amp;=\\frac{-2(x^2+x+1)}{x-1}+\\frac{3(x^2+x+1)}{(x-1)^2}+Mx+N \\ \\frac{3x_{0}+6}{(x_{0}-1)^2}\u0026amp;=\\frac{-2(x_{0}^2+x_{0}+1)}{x_{0}-1}+\\frac{3(x_{0}^2+x_{0}+1)}{(x_{0}-1)^2}+Mx_{0}+N \\ \\frac{3x_{0}+6}{(x_{0}-1)^2}\u0026amp;=Mx_{0}+N \\ \\frac{3x_{0}+6}{x_{0}^2+x_{0}+1-3x_{0}}\u0026amp;=Mx_{0}+N \\ \\frac{3x_{0}+6}{-3x_{0}}\u0026amp;=Mx_{0}+N \\ -1-\\frac{2}{x_{0}}\u0026amp;=Mx_{0}+N \\ \\sqrt{ 3 }i\u0026amp;=\\frac{\\sqrt{ 3 }}{2}Mi+\\left( N-\\frac{M}{2} \\right) \\end{align} $$ 得出： $$ \\left{ \\begin{align} M=2 \\ N=1 \\end{align} \\right. $$\n复变运算推广\r复变运算不止可以用于分子为常数，它可以配推广到分子为 $F(x)$. 这在解决高次分母有理式的裂项很有帮助。\n🔗 例题 $\\int \\frac{1}{1+x^{6}} , dx$\n","date":"2024-11-26T13:13:34+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%A7%AF%E5%88%86/%E7%95%99%E6%95%B0%E6%B3%95-%E6%B1%82%E6%9C%89%E7%90%86%E5%BC%8F%E5%88%86%E8%A7%A3/","title":"留数法 求有理式分解"},{"content":" 定义\r满足以下条件的数据结构：\n完全二叉树 (:LiLink: 树\r) 子节点键值 都 $\\le$ 或者 $\\ge$ 父节点键值 分类\r大/小根堆：\n小根堆：跟 $\\le$ 子 大根堆：根 $\\ge$ 子 :LiLink: STL 中的 std::priority_queue\r二叉堆\r定义\r同时满足以下条件：\n是 堆 是 完全二叉树 用途\r主要用于随时 $O(1)$ 查询最值。\n实现\r调整策略\r调整策略分为两种 (大根堆)：\n向上调整 1 2 3 4 5 6 auto heap::up(ID x) -\u0026gt; void { while(x \u0026gt; 0 \u0026amp;\u0026amp; h[x / 2] \u0026lt; h[x]) { std::swap(h[x / 2], h[x]); x /= 2; } } 向下调整 1 2 3 4 5 6 7 8 9 10 auto heap::down(ID x) -\u0026gt; void { while(x * 2 \u0026lt; size) { auto child = x * 2; if (child + 1 \u0026lt; size \u0026amp;\u0026amp; h[child + 1] \u0026gt; h[child]) child = child + 1; if (h[child] \u0026lt;= h[x]) break; std::swap(h[child], h[x]); x = child; } } 插入\r在最下层的最右侧插入 向上调整 时间复杂度 $O(\\log{n})$。 1 2 3 4 auto Heap::push(T\u0026amp;\u0026amp; val) { h[++size] = std::move(val); up(size); } 删除\r将根节点与最后一个叶节点交换 交换厚的根节点向下调整 时间复杂度 $O(\\log{n})$。 1 2 3 4 auto Heap::pop() -\u0026gt; void { std::swap(h[1], h[size]); down(1); } 建堆\rTODO：继续学习建堆 Note\r你完全可以使用 STL 中的 std::priority_queue 作为堆。 其中：\n大根堆：std::priority_queue\u0026lt;T\u0026gt; (默认) 小根堆：std::priority_queue\u0026lt;T, std::vector\u0026lt;T\u0026gt;, std::greater\u0026lt;T\u0026gt;\u0026gt; 对顶堆\r定义\r由一个大根堆和小根堆构成。\n以 第 $k$ 大 问题为例：\n小根堆维护 前 $k$ 大元素，于是保证其堆顶是 第 $k$ 大元素。 大根堆维护其余剩余元素。 只需要一直维持小根堆的 size 是 $k$ 即可。 用途\r解决 top-n 问题。\n实现\r以 第 $k$ 大 问题为例。\n整体而言，对顶堆支持以下操作：\n维护 ::update()：将小根堆 size 保持在 $k$ 小根堆 size 过大 $\\Rightarrow$ 往大根堆塞 小根堆 size 过小 $\\Rightarrow$ 从大根堆取 插入元素 ::push()： 先插入元素 元素 $\\ge$ 小根堆.top() $\\Rightarrow$ 插入小根堆 元素 $\\lt$ 小根堆.top() $\\Rightarrow$ 插入大根堆 维护队列 ::update() 查询第 $k$ 大元素 ::top()：返回小根堆堆顶 删除第 $k$ 大元素 ::pop()：先 pop 小根堆堆顶，再 ::update() 更改第 $k$ 大元素 结构\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 大根堆 template\u0026lt;typename T\u0026gt; using MinHeap = std::priority_queue\u0026lt;T\u0026gt;; // 小根堆 template\u0026lt;typename T\u0026gt; using MaxHeap = std::priority_queue\u0026lt;T, std::vector\u0026lt;T\u0026gt;, std::greater\u0026lt;T\u0026gt;\u0026gt;; // 第k大对顶堆 template\u0026lt;typename T\u0026gt; struct Heap { MinHeap\u0026lt;T\u0026gt; minh; MaxHeap\u0026lt;T\u0026gt; maxh; std::size_t top_n = 1; // 退化为朴素堆 }; 维护\r1 2 3 4 5 6 7 8 9 10 auto Heap::update() -\u0026gt; void { while (maxh.size() \u0026lt; top_n \u0026amp;\u0026amp; !minh.empty()) { maxh.push(minh.top()); minh.pop(); } while (maxh.size() \u0026gt; top_n) { minh.push(maxh.top()); maxh.pop(); } } 插入\r1 2 3 4 5 6 7 8 9 auto Heap::push(T\u0026amp;\u0026amp; val) -\u0026gt; void { if (maxh.empty() || val\u0026gt;=maxh.top()) { maxh.push(std::move(val)); update(); } else { minh.push(std::move(val)); update(); } } 查询\r1 auto Heap::top() const -\u0026gt; const T\u0026amp; { return maxh.top(); } 配对堆\rTODO：学习偏对堆 左偏树\rTODO：学习左偏树 ","date":"2024-11-25T21:22:22+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/","title":"堆"},{"content":"定义\r树状结构，支持两种操作：\n合并 查询：是否在同一集合 由于其查询功能，并查集常用于检查图の连通性。\nAttention\r注意有些题目使用 1~n 编号而不是 0 ~ n-1，图论问题都要注意编号问题，否则：\n数组越界访问 $\\Rightarrow$ RE 逻辑错误 $\\Rightarrow$ WA 实现 | 无向图\r结构\r开数组池化避免 new/delete .\n1 2 3 4 5 6 7 8 9 10 11 struct Dsu { using ID = size_t; std::vector\u0026lt;ID\u0026gt; pa; // parent std::vector\u0026lt;size_t\u0026gt; size; // 启发式合并维护 size Dsu(size_t sz) : pa(sz), size(sz, 1) { std::iota(pa.begin(), pa.end(), 0); // [^1] } }; // [^1]: Set parent as self, so that every node is a root. 查询\r朴素做法\r如下\n1 auto Dsu::find(ID x) -\u0026gt; ID { return pa[x] == x ? x : find(pa[x]); } 可以用路径压缩减少寻父次数到 1。\n路径压缩\r即把树结构扁平化\n1 2 // with 路径压缩 auto Dsu::find(ID x) -\u0026gt; ID { return pa[x] == x ? x : pa[x] = find(pa[x]); } Warning\r路径压缩一次可能会造成大量修改，并非 lazy。因此有时候路径压缩并不适合使用。例如：\n可持久化并查集 线段树分治 + 并查集 这种情况一般使用只包含启发式合并的并查集\n合并\r只需将其中一个树的根接到另一个根上即可。\ngraph LR\r2 --\u003e 1\r3 --\u003e 1\r4 --\u003e 3\r5 --\u003e 3\r7 --\u003e 6\r8 --\u003e 6\r6 -.-\u003e 1\r启发式合并\r点数/深度任选其一维护作为估价函数。 为了防止退化，降低复杂度，一般选择将节点少的根连到另一棵树 一般只使用路径压缩而不使用启发式合并，一般也不会超时，时间复杂度能达到 $O(m\\alpha(m, n))$。 如果只使用启发式合并而不使用路径压缩，时间复杂度是 $O(m\\log{n})$。因为路径压缩并不是什么时候都能用，所以这种情况也要考虑。 简而言之：\n路径压缩 + 启发式合并：$O(\\alpha(n))$ 路径压缩 only：$O(m\\alpha(m, n))$ 启发式合并 only: $O(m\\log{n})$ 用于不能使用路径压缩时 都不用：:LiCross: 1 2 3 4 5 6 7 8 9 // with 启发式合并 维护点数 auto Dsu::unite(size_t x, size_t y) -\u0026gt; void { x = find(x); y = find(y); if (x == y) return; if (size[x] \u0026lt; size[y]) std::swap(x, y); pa[y] = x; size[x] += size[y]; } 删除\r只能用于叶结点。\n1 2 3 4 auto Dsu::erase(ID x) -\u0026gt; void { size[find(x)]--; pa[x] = x; } 可以为每个节点制作副本，将其副本作为父亲。\n移动\r只能用于叶结点。\n1 2 3 4 5 6 7 auto Dsu::move(ID from, ID to) -\u0026gt; void { auto pa_from = find(from); auto pa_to = find(to); if (pa_from == pa_to) return; size[pa_from]--; size[pa_to]++; } 习题 TODO\rP1525 [NOIP2010 提高组] 关押罪犯\r(@2025-01-10) 📅 (due_date:: 2024-11-26) 实现 | 有向图求最小环\r结构\r1 2 3 4 5 6 7 8 struct Dsu { std::vector\u0026lt;size_t\u0026gt; pa; std::vector\u0026lt;size_t\u0026gt; dist; // 维护到祖先的距离 Dsu(size_t n) : pa(n + 1), dist(n + 1, 0) { std::iota(pa.begin(), pa.end(), 0); } }; 查询\r1 2 3 4 5 6 7 8 auto Dsu::find(size_t x) -\u0026gt; size_t { if (x != pa[x]) { size_t last = pa[x]; pa[x] = find(pa[x]); dist[x] += dist[last]; } return pa[x]; } 合并\r1 2 3 4 5 6 7 8 9 10 11 12 size_t Dsu::min_ring_len = std::numeric_limits\u0026lt;size_t\u0026gt;::max(); auto Dsu::unite(size_t from, size_t to) -\u0026gt; void { auto f_from = find(from); auto f_to = find(to); if (f_from != f_to) { pa[f_to] = f_from; dist[to] = dist[from] + 1; } else { min_ring_len = std::min(min_ring_len, dist[from] + dist[to] + 1); } } 实现 | 更多应用\r","date":"2024-11-24T23:31:44+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/","title":"并查集"},{"content":"定义\r如其名，线段 $\\Leftrightarrow$ 区间。\n将线段不断二分作为子节点，从而构成树缓存。\n用途\r维护区间信息，支持：\n单点修改 区间修改 区间查询 实现\rInfo\r由于时间复杂度问题，涉及多种运算及更多更复杂的情况，无法总结出一个 generic 的线段树，故这里只给出一个支持区间加法 \u0026amp; 区间求和的线段树实现。\n区间 Utils\r1 2 3 4 5 6 7 8 9 10 11 12 13 template\u0026lt;typename T\u0026gt; struct SegmentTree { static constexpr auto left(size_t p) -\u0026gt; size_t { return p \u0026lt;\u0026lt; 1; } static constexpr auto right(size_t p) -\u0026gt; size_t { return (p \u0026lt;\u0026lt; 1) | 1; } static constexpr auto mid(size_t s, size_t t) -\u0026gt; size_t { return (s + t) \u0026gt;\u0026gt; 1; } static constexpr auto len(size_t s, size_t t) -\u0026gt; size_t { return t - s + 1; } // ... }; 结构\r对于给定的数据数组 $a[n]$，维护一个池化缓存数组 $d[4n]$ 管理所有结点内存。\n缓存数组大小分析\rTODO 其中 $d[i]$ 的子节点为 $d[2i]$ 和 $d[2i + 1]$，他们的管辖区间是：\n父节点 $d[i]$ $\\Rightarrow$ $[s .. t]$ 左儿子 $d[2i]$ $\\Rightarrow$ $[s .. \\frac{s + t}{2}]$ 右儿子 $d[2i + 1]$ $\\Rightarrow$ $[\\frac{s + t}{2} + 1 .. t]$ 1 2 3 4 5 template\u0026lt;typename T\u0026gt; struct SegmentTree { std::vector\u0026lt;T\u0026gt; tree; std::vector\u0026lt;T\u0026gt; lazy; // lazy add }; 于是建树如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * @brief 建树 * @param s 左边界 * @param t 右边界 * @param p 当前节点(父节点) */ template\u0026lt;typename T\u0026gt; auto SegmentTree\u0026lt;T\u0026gt;::build(size_t s, size_t t, size_t p) -\u0026gt; void { if (s == t) { d[p] = a[s]; return; } size_t m = s + ((s + t) \u0026gt;\u0026gt; 1); // middle build(s, m, p * 2); build(m + 1, t, p * 2 + 1); d[p] = op(d[p * 2], d[p * 2 + 1]); } Lazy Tag\r为了控制时间复杂度，我们没必要每次修改都维护更新整棵树。我们只修改实际数据，打上标记，在下次询问时才更新树。这个标记就叫 「lazy tag」，这种优化方法叫做 「lazy propagation」。\n注意，每个节点的 lazy tag 是针对子区间的未更新标记，当前节点的修改是即时更新的。\n为了维护 lazy tag，我们引入 pushdown 操作：\n1 2 3 4 5 6 7 8 9 10 11 template\u0026lt;typename T\u0026gt; auto SegmentTree\u0026lt;T\u0026gt;::pushdown(size_t s, size_t t, size_t p) -\u0026gt; void { if (lazy[p] != 0) { auto m = mid(s, t); lazy[left(p)] += lazy[p]; lazy[right(p)] += lazy[p]; tree[left(p)] += lazy[p] * len(s, m); tree[right(p)] += lazy[p] * len(m + 1, t); lazy[p] = 0; } } Attention\rpushdown 保证了子区间的正确性，所以在操作子区间前都要 pushdown。\n为了方便记忆，还可以引入一个 pushup 函数，用于在子区间更新后更新父区间：\n1 2 3 4 template\u0026lt;typename T\u0026gt; auto SegmentTree\u0026lt;T\u0026gt;::pushup(size_t s, size_t t, size_t p) { tree[p] = tree[left(p)] + tree[right(p)]; } 区间修改 (加)\r1 2 3 4 5 6 7 8 9 10 11 12 13 template\u0026lt;typename T\u0026gt; auto SegmentTree::add(const T\u0026amp; val, size_t l, size_t r, size_t s, size_t t, size_t p) -\u0026gt; void { if (l \u0026lt;= s \u0026amp;\u0026amp; t \u0026lt;= r) { lazy[p] += val; tree[p] += val * len(s, t); return ; } pushdown(s, t, p); // 涉及子区间, 必须先 pushdown 保证正确性 auto m = mid(s, t); if (l \u0026lt;= m) add(val, l, r, s, m, left(p)); if (m + 1 \u0026lt;= r) add(val, l, r, m + 1, t, right(p)); pushup(s, t, p); } 区间查询\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;typename T\u0026gt; auto SegmentTree\u0026lt;T\u0026gt;::query(size_t l, size_t r, size_t s, size_t t, size_t p) -\u0026gt; T { if (l \u0026lt;= s \u0026amp;\u0026amp; t \u0026lt;= r) return tree[p]; pushdown(s, t, p); auto m = mid(s, t); T sum {}; if (l \u0026lt;= m) sum += query(l, r, s, m, left(p)); if (m + 1 \u0026lt;= r) sum += query(l, r, m + 1, t, right(p)); return sum; } template\u0026lt;typename T\u0026gt; auto SegmentTree\u0026lt;T\u0026gt;::query(size_t l, size_t r) -\u0026gt; T { return query_impl(l, r, 1, size(), 1); // 从根节点开始 } TODO: 因为后续数据结构进阶内容蓝桥杯省赛不太重点考，所以先把图论补起来再回来从线段树啃起。。🔽 (@2025-01-28) ","date":"2024-11-22T11:57:35+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/","title":"线段树"},{"content":"Tutorial\rVideo\r(Day 2 尾巴才装了 Vulkan，Day 3 才开始写 Vulkan \u0026hellip; )\nExamples\r官网资源\rhttps://docs.vulkan.org/guide/latest/index.html\rhttps://docs.vulkan.org/tutorial/latest/00_Introduction.html\r","date":"2024-11-21T22:19:23+08:00","permalink":"//localhost:1313/post/%E5%BC%80%E5%8F%91/vulkan/vulkan-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/","title":"Vulkan 学习资料汇总"},{"content":" 前缀函数 $\\pi[i]$\r定义\r最长相等 真前缀 \u0026amp; 真后缀 の 长度 $$ \\pi[i] = \\max_{k=0\u0026hellip;i}{{k: s[0 \u0026hellip; k] = s[i - k + 1 \u0026hellip; i]}} $$\n例子\r对于字符串 abcabcd 的前缀函数 $\\pi[i]$ ：\n$i$ $\\pi[i]$ 子串 相等前后缀 0 0 a null 1 0 ab null 2 0 abc null 3 1 abca a 4 2 abcab ab 5 3 abcabc abc 6 0 abcabcd null 实现\r朴素实现\r暴力模拟匹配，从大到小，匹配到就返回\n1 2 3 4 5 6 for (int i = 0; i \u0026lt; str.size(); i++) for (int j = i - 1; j \u0026gt;= 0; j--) if (str.substr(0, j) == str.substr(i - j + 1, j)) { pi[i] = j; break; } 得配优化\r观察到：$\\pi[i + 1] - \\pi[i] \\le 1$\n1 2 3 4 5 6 for (int i = 0; i \u0026lt; str.size(); i++) for (int j = pi[i - 1] + 1; j \u0026gt;= 0; j--) if (str.substr(0, j) == str.substr(i - j + 1, j)) { pi[i] = j; break; } 失配优化\r在 $\\pi[i] = \\pi[i - 1] + 1$ 失配后，假定 $\\pi[i] = j + 1$ 得配，则有：\n$$ \\begin{cases} str[j] = str[i] \\ str[0 \u0026hellip; j - 1] = str[i - j \u0026hellip; i - 1] = str[\\pi[i] - j + 1, \\pi[i] - 1] \\end{cases} $$ 第二条比较关键，即 $j$ 在 $str[0 \u0026hellip; i]$ 是真前后缀匹配的，$\\pi[i]$ 也是在 $str[0 \u0026hellip; i]$ 真前后缀匹配的 $\\Rightarrow$ $j$ 在 $str[0 \u0026hellip; \\pi[i] - 1]$ 是前后缀匹配的\n于是有递推公式：\n$$ j^{(n)} = \\pi[j^{(n - 1)} - 1] $$\n:star:最终实现：\n1 2 3 4 5 6 7 for (int i = 0; i \u0026lt; str.size(); i++) { int j = pi[i - 1]; while(j \u0026gt; 0 \u0026amp;\u0026amp; str[j] != str[i]) j = pi[j - 1]; if (str[i] == str[j]) j++; // 判断得配，str[i] = str[j] 也算一位 // 如果是失配，str[i] != str[j]，那么 j = 0 不用 ++ pi[i] = j; } 时间复杂度 $O(n)$ ，在线算法。\nKMP\r适用：字符串 $s$，文本 $t$ . 求 $s$ 在 $t$ 出现的所有位置 (occurrence)\n实现\r构造一个字符串 $str = s+#+t$，其中 $#$ 是一个同时不存在于 $s$ 和 $t$ 的字符.\n记 $\\pi[i]$ 是 $str$ 的前缀函数. 因为存在 $#$ ，所以 $\\forall i, \\pi[i] \\le \\left| s \\right|$ .\n所以 $s = t[i .. i + \\left| s \\right| - 1] \\Leftrightarrow \\pi[i + 2 * \\left| s \\right|] = \\left| s \\right|$ .\n1 2 3 4 5 6 7 8 9 auto find_occurrences(std::string_view text, std::string_view pattern) -\u0026gt; std::vector\u0026lt;int\u0026gt; { auto str = std::string { pattern } + \u0026#39;#\u0026#39; + text; std::vector\u0026lt;int\u0026gt; occurences; auto prefix_fn = get_prefix_fn(str); // 前缀函数 for (int i = pattern.size() + 1; i \u0026lt;= str.size(); i++) if (prefix_fn[i] == pattern.size()) occurences.emplace_back(i - 2 * pattern.size()); return occurences; } TODO: 因为字符串在 oi 中不算热点内容，所以暂时先更到 kmp 🔽 ","date":"2024-11-21T18:50:02+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%97%E7%AC%A6%E4%B8%B2/kmp/","title":"KMP"},{"content":" 原理\r哈希： any -\u0026gt; int/long long，结果用于下标，实现随机访问。本质是离散化。 字符串哈希：string -\u0026gt; index\n实现 | 哈希算法\r本质是转换为进制为 $base$ 的进制数： $$ hash = (str)_{base} $$ 但由于下标类型大小有限，所以需要取模 $mod$ 。\nInfo\r$base$ 选择：大于每位数字最大值，不含 $mod$ 质因子：27, 233, 19260817 $mod$ 选择： 一个 $10^9$ 质数做单哈希：1e9+7 ，但是任意 $\\sqrt{10^9}$ 个串就容易哈希冲突 两个 $10^9$ 质数做双哈希：19260817 \u0026amp; 19660813 用 unsigned long long 自然溢出 [!朴素实现] 如下\n1 2 for (int i = 0; i \u0026lt; str.size(); i++) hash = (hash + str[i] * pow(base, i)) % mod; 时间复杂度由于 pow 为 $O(n^2)$ 。 所以使用滚动优化/累积优化降低复杂度到 $O(n)$ 。\n单哈希\n1 2 for (char c : str) hash = (hash * base + c) % mod; // mod = 1e9 + 7 :star:自然溢出\n1 2 3 unsigned long long hash = 0; for (char c : str) hash = hash * base + c; 双哈希\n1 2 3 4 5 6 7 8 unsigned long long mod1 = 19260817; unsigned long long mod2 = 19660813; using Hash = unsigned long long; auto hash1(const std::string\u0026amp; str) -\u0026gt; Hash; auto hash2(const std::string\u0026amp; str) -\u0026gt; Hash; auto compare_hash(const std::string\u0026amp; lhs, const std::string\u0026amp; rhs) -\u0026gt; bool { return hash1(lhs) == hash1(rhs) \u0026amp;\u0026amp; hash2(lhs) == hash2(rhs); } 另法 | 用 STL 自带 hash 的容器 / std::hash 说的就是 std::set/std::unordered_map 。\n","date":"2024-11-21T17:52:36+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/","title":"字符串哈希"},{"content":"就是灵活运用这么个公式： $$ \\int_{a}^{b} f(x) , dx = \\int_{a}^{b} f(a + b - x) , dx $$\n","date":"2024-11-20T15:20:17+08:00","permalink":"//localhost:1313/post/%E5%AD%A6%E6%9C%AF/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/%E7%A7%AF%E5%88%86/%E5%8C%BA%E9%97%B4%E5%86%8D%E7%8E%B0/","title":"区间再现"}]