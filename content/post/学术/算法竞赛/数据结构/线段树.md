---
tags:
  - algorithm
  - æ•°æ®ç»“æ„
dg-publish: "true"
title: çº¿æ®µæ ‘
date: 2024-11-22T11:57:35+08:00
lastmod: 2024-12-07T19:49:12+08:00
publish: true
---

## å®šä¹‰

å¦‚å…¶åï¼Œçº¿æ®µ $\Leftrightarrow$ åŒºé—´ã€‚

å°†çº¿æ®µä¸æ–­äºŒåˆ†ä½œä¸ºå­èŠ‚ç‚¹ï¼Œä»è€Œæ„æˆæ ‘ç¼“å­˜ã€‚
## ç”¨é€”

ç»´æŠ¤**åŒºé—´ä¿¡æ¯**ï¼Œæ”¯æŒï¼š
+ å•ç‚¹ä¿®æ”¹
+ åŒºé—´ä¿®æ”¹
+ åŒºé—´æŸ¥è¯¢

## å®ç°

>[!INFO]
ç”±äºæ—¶é—´å¤æ‚åº¦é—®é¢˜ï¼Œæ¶‰åŠå¤šç§è¿ç®—åŠæ›´å¤šæ›´å¤æ‚çš„æƒ…å†µï¼Œæ— æ³•æ€»ç»“å‡ºä¸€ä¸ª generic çš„çº¿æ®µæ ‘ï¼Œæ•…è¿™é‡Œåªç»™å‡ºä¸€ä¸ªæ”¯æŒåŒºé—´åŠ æ³• & åŒºé—´æ±‚å’Œçš„çº¿æ®µæ ‘å®ç°ã€‚

### åŒºé—´ Utils

```cpp
template<typename T>
struct SegmentTree {
	static constexpr auto left(size_t p) -> size_t { return p << 1; }
	static constexpr auto right(size_t p) -> size_t { return (p << 1) | 1; }
	static constexpr auto mid(size_t s, size_t t) -> size_t { 
		return (s + t) >> 1; 
	}
	static constexpr auto len(size_t s, size_t t) -> size_t {
		return t - s + 1;
	}
	
	// ...
};
```
### ç»“æ„

å¯¹äºç»™å®šçš„æ•°æ®æ•°ç»„ $a[n]$ï¼Œç»´æŠ¤ä¸€ä¸ªæ± åŒ–ç¼“å­˜æ•°ç»„ $d[4n]$ ç®¡ç†æ‰€æœ‰ç»“ç‚¹å†…å­˜ã€‚

> [!ç¼“å­˜æ•°ç»„å¤§å°åˆ†æ]
> - [ ]  TODO

å…¶ä¸­ $d[i]$ çš„å­èŠ‚ç‚¹ä¸º $d[2i]$ å’Œ $d[2i + 1]$ï¼Œä»–ä»¬çš„ç®¡è¾–åŒºé—´æ˜¯ï¼š
+ çˆ¶èŠ‚ç‚¹ $d[i]$ $\Rightarrow$ $[s .. t]$
+ å·¦å„¿å­ $d[2i]$ $\Rightarrow$ $[s .. \frac{s + t}{2}]$
+ å³å„¿å­ $d[2i + 1]$ $\Rightarrow$ $[\frac{s + t}{2} + 1 .. t]$

```cpp
template<typename T>
struct SegmentTree {
	std::vector<T> tree;
	std::vector<T> lazy; // lazy add
};
```

äºæ˜¯å»ºæ ‘å¦‚ä¸‹ï¼š

```cpp
/**
 * @brief å»ºæ ‘
 * @param s å·¦è¾¹ç•Œ
 * @param t å³è¾¹ç•Œ
 * @param p å½“å‰èŠ‚ç‚¹(çˆ¶èŠ‚ç‚¹)
 */
template<typename T>
auto SegmentTree<T>::build(size_t s, size_t t, size_t p) -> void {
	if (s == t) {
		d[p] = a[s];
		return;
	}
	size_t m = s + ((s + t) >> 1); // middle
	build(s, m, p * 2);
	build(m + 1, t, p * 2 + 1);
	d[p] = op(d[p * 2], d[p * 2 + 1]);
}
```

### Lazy Tag

 ä¸ºäº†æ§åˆ¶æ—¶é—´å¤æ‚åº¦ï¼Œæˆ‘ä»¬æ²¡å¿…è¦æ¯æ¬¡ä¿®æ”¹éƒ½ç»´æŠ¤æ›´æ–°æ•´æ£µæ ‘ã€‚æˆ‘ä»¬åªä¿®æ”¹å®é™…æ•°æ®ï¼Œæ‰“ä¸Šæ ‡è®°ï¼Œåœ¨ä¸‹æ¬¡è¯¢é—®æ—¶æ‰æ›´æ–°æ ‘ã€‚è¿™ä¸ªæ ‡è®°å°±å« **ã€Œlazy tagã€**ï¼Œè¿™ç§ä¼˜åŒ–æ–¹æ³•å«åš  **ã€Œlazy propagationã€**ã€‚
 
æ³¨æ„ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„ lazy tag æ˜¯é’ˆå¯¹å­åŒºé—´çš„æœªæ›´æ–°æ ‡è®°ï¼Œå½“å‰èŠ‚ç‚¹çš„ä¿®æ”¹æ˜¯å³æ—¶æ›´æ–°çš„ã€‚

ä¸ºäº†ç»´æŠ¤ lazy tagï¼Œæˆ‘ä»¬å¼•å…¥ `pushdown` æ“ä½œï¼š

```cpp
template<typename T>
auto SegmentTree<T>::pushdown(size_t s, size_t t, size_t p) -> void {
	if (lazy[p] != 0) {
		auto m = mid(s, t);
		lazy[left(p)] += lazy[p];
		lazy[right(p)] += lazy[p];
		tree[left(p)] += lazy[p] * len(s, m);
		tree[right(p)] += lazy[p] * len(m + 1, t);
		lazy[p] = 0;
	}
}
```

> [!ATTENTION]
`pushdown` ä¿è¯äº†å­åŒºé—´çš„æ­£ç¡®æ€§ï¼Œæ‰€ä»¥åœ¨æ“ä½œå­åŒºé—´å‰éƒ½è¦ `pushdown`ã€‚

ä¸ºäº†æ–¹ä¾¿è®°å¿†ï¼Œè¿˜å¯ä»¥å¼•å…¥ä¸€ä¸ª `pushup` å‡½æ•°ï¼Œç”¨äºåœ¨å­åŒºé—´æ›´æ–°åæ›´æ–°çˆ¶åŒºé—´ï¼š

```cpp
template<typename T>
auto SegmentTree<T>::pushup(size_t s, size_t t, size_t p) {
	tree[p] = tree[left(p)] + tree[right(p)];
}
```
### åŒºé—´ä¿®æ”¹ (åŠ )

```cpp
template<typename T>
auto SegmentTree::add(const T& val, size_t l, size_t r, size_t s, size_t t, size_t p) -> void {
	if (l <= s && t <= r) {
		lazy[p] += val;
		tree[p] += val * len(s, t);
		return ;
	}
	pushdown(s, t, p); // æ¶‰åŠå­åŒºé—´, å¿…é¡»å…ˆ pushdown ä¿è¯æ­£ç¡®æ€§
	auto m = mid(s, t);
	if (l <= m) add(val, l, r, s, m, left(p));
	if (m + 1 <= r) add(val, l, r, m + 1, t, right(p));
	pushup(s, t, p);
}
```
### åŒºé—´æŸ¥è¯¢

```cpp
template<typename T>
auto SegmentTree<T>::query(size_t l, size_t r, size_t s, size_t t, size_t p) -> T {
	if (l <= s && t <= r) return tree[p];
	pushdown(s, t, p);
	auto m = mid(s, t);
	T sum {};
	if (l <= m) sum += query(l, r, s, m, left(p));
	if (m + 1 <= r) sum += query(l, r, m + 1, t, right(p));
	return sum;
}

template<typename T>
auto SegmentTree<T>::query(size_t l, size_t r) -> T {
	return query_impl(l, r, 1, size(), 1); // ä»æ ¹èŠ‚ç‚¹å¼€å§‹
}
```

- [ ] TODO: å› ä¸ºåç»­æ•°æ®ç»“æ„è¿›é˜¶å†…å®¹è“æ¡¥æ¯çœèµ›ä¸å¤ªé‡ç‚¹è€ƒï¼Œæ‰€ä»¥å…ˆæŠŠå›¾è®ºè¡¥èµ·æ¥å†å›æ¥ä»çº¿æ®µæ ‘å•ƒèµ·ã€‚ã€‚ğŸ”½ (@2024-12-31)
